<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何处有所栖</title>
  
  <subtitle>君子不立危墙之下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gpdstudy.club/"/>
  <updated>2019-06-18T01:52:11.136Z</updated>
  <id>http://gpdstudy.club/</id>
  
  <author>
    <name>啥是gay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Integer之你所不知道的bug</title>
    <link href="http://gpdstudy.club/2019/06/16/integer-bug/"/>
    <id>http://gpdstudy.club/2019/06/16/integer-bug/</id>
    <published>2019-06-15T17:54:10.000Z</published>
    <updated>2019-06-18T01:52:11.136Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 10:35:48 GMT+0800 (GMT+08:00) --><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>本来以为自己的博客没几个人看，但是群里的小伙伴却很认真的看完了，顺便还帮我找了几个语病，提了不少建议。这里我要感谢一下<a href="https://github.com/Rukawalee" target="_blank" rel="noopener">@Rukawalee</a>,这位同学是我的审稿小王子，不辞辛劳的帮我审稿，调整语言和篇幅，修改一些语病，以达到最好的阅读体验(内心OS：好歹初中语文年级第一，怎会沦落为现在这样语病百出的地步，哭唧唧)。应小伙伴们的建议，我将这篇文章进行重写，添加了一些Integer的知识点，同时也增加了一些例子，让同学们能更加清晰，更加深入的了解Integer的秘密。当然，这个知识点并不仅仅局限于int和Integer，所有的基础类型和包装类型的知识点都是互通的，这里只是以int和Integer为例而已。</p><h2 id="bug缘起"><a href="#bug缘起" class="headerlink" title="bug缘起"></a>bug缘起</h2><p>今天日常在牛客群里和小伙伴们吹水聊天，我聊到代码规范的时候吐槽了一波，公司每个人的代码规范都不统一，int和integer有的人用equals有的人用==。然后建议统一用equals。于是贴了一波代码为了佐证一下我的建议吧。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我说，如果写出这样的代码，直接就掉空指针异常坑里了，所以还是最好统一使用equals方法。然而，群里的小伙伴可能是为了捧哏故意说不知道有啥问题。嗯，于是我不要脸的好为人师了一把，既然大家给面子，那就装一波(手动滑稽)。这次，我就从源头上来剖析包装类和基本数据类型的区别以及bug出现的原因。</p><h2 id="int及其包装类"><a href="#int及其包装类" class="headerlink" title="int及其包装类"></a>int及其包装类</h2><h3 id="Integer的起源"><a href="#Integer的起源" class="headerlink" title="Integer的起源"></a>Integer的起源</h3><p><font color="red">在Java中，因为基本类型并不是一个类，它是以值的形式存储在虚拟机内存中。因此它不能在Object之间直接引用。</font>比如说在Map中作为泛型使用或者像Object一样调用方法。如果我们想将基本类型当做类来处理，这个时候我们就需要使用到包装类Integer了。包装类是JDK1.0中提供的，他解决了基本数据类型和Object之间不能直接传递的缺陷。</p><h3 id="int的自动装箱和拆箱"><a href="#int的自动装箱和拆箱" class="headerlink" title="int的自动装箱和拆箱"></a>int的自动装箱和拆箱</h3><p>在JDK1.5之前，int和Integer是不能直接比较的，它需要我们自己显式的调用intValue()进行比较。但是在JDK1.5之后提供了拆箱和装箱的功能之后，我们可以直接将其进行==比较。当然，它同时还提供了其他的便利，待会我会以代码进行一一解释。</p><h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p>我们看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>;</span><br><span class="line">        encasement(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encasement</span><span class="params">(Object i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            System.out.println(<span class="string">"int 被包装成了 Integer"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"int 并没有被包装成Integer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们思考一下，上面的代码会输出什么呢，相信聪明的读者已经知道了答案，那就是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> 被包装成了 Integer</span><br></pre></td></tr></table></figure><p>接下来，我们来解析上面的一段代码，因为引入了自动装箱机制，<font color="red">“Integer i = 10”实际上是调用了valueOf()方法，所以上面的方法等同于”Integer i = Integer.valueOf(10)”。注意，这个不等同于”Integer i = new Integer(10)”。</font>为什么强调这一点呢，我待会会讲到。</p><p>然后就是第二行代码了，我们前面说过，int不能在Object之间直接引用，为什么我的int能被encasement方法接收呢，原因也是内部做了装箱操作，在方法的传递中，我们的编译器悄悄的把int转换成了Integer，从输出结果也可以看出来了。</p><h4 id="Integer的-到底比较的是什么"><a href="#Integer的-到底比较的是什么" class="headerlink" title="Integer的==到底比较的是什么"></a>Integer的==到底比较的是什么</h4><p>我们大家应该都知道，<font color="red">==除基本类型比较的是值之外，Object类型都是比较地址的。</font>Integer也不例外，但是细心的小伙伴可能会发现下面这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">10</span>; <span class="comment">// 实际为 Integer a = Integer.valueOf(10);</span></span><br><span class="line">        Integer b = <span class="number">10</span>;</span><br><span class="line">        Integer c = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line">        Integer e = <span class="number">200</span>;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(b == c);</span><br><span class="line">        System.out.println(d == e);</span><br><span class="line">        System.out.println(d.equals(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><font color="red">同学们注意了，以上均为Integer，实际上比较的是对象的引用(即地址)。</font>但是为什么第一个会输出true呢，按照常理来说，第一个输出结果应该为false呀。同学们别急，听我慢慢给你们解释。解释前我们先看一段源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    ...<span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        ...<span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在上面已经说到过对Integer直接赋值，编译器会自动优化成对valueOf()方法的调用。所以蹊跷必然出现在这个valueOf()方法。通过源码我们可以发现，<font color="red">Integer内部有一个IntegerCache的内部类，这个内部类里面维护了一个cache[]的Integer数组，数组的大小为256，范围是-128~127。而我们的valueOf()方法是判断int的值是否是在这个区间内。如果在这个区间内，我们返回的则是cache数组中的Integer对象，否则new一个新的Integer对象出来。</font>这下我们应该就明白了为什么第一个会输出true了，因为他们返回的都是同一个对象，当然地址就是一样的啦。<font color="red">第二个输出为false的原因是new关键字的含义就是从内存中申请分配空间，所以地址必然是不一样的</font>。至于第三个为什么false，那是因为超出了区间调用了new Integer()，所以地址也是不一样的。<font color="red">这也是为什么装箱不是调用的new，因为如果调用的是new，那么第一个输出只会是false了。</font>而我们的equals()方法则是通过上一节讲的装箱操作，将int转换为Integer之后通过比较类型再将两个对象的value值进行比较，所以只要值相等就会返回true，参考第四个输出。对了，IntegerCache的区间是可调的，至于具体操作，因为不在这篇博客讲解的范围内，大家可自行google或者百度。</p><h4 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h4><p>还是先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        encasement(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encasement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>我们来详解一下，我们之前说过<font color="red">除了基本数据类型，java对象==比较的都是地址，因此基本数据类型是无法和除包装类以外的Object使用==进行比较。同时也不能在Object之间直接引用。</font>那为什么上面代码可以通过编译并且输出true呢，那是因为int包装类型在和int进行比较的时候会隐式的调用intValue()方法，所以在”a == b”这一句代码中，其实真正的语法是”a == b.intValue()”。”encasement(i)”同理，在进行参数传递的时候调用了intValue()方法。因此我们可以使用int来接收它。</p><h2 id="为什么会有bug"><a href="#为什么会有bug" class="headerlink" title="为什么会有bug"></a>为什么会有bug</h2><p>好吧，我们回到之前的问题中来，我相信大家都快忘了问题是什么，没关系，我把代码再贴一下。顺便请问一下同学们，下面的代码会出现什么bug呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细思考一下哦，思考完之后看看下面的结果和你猜想的是不是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">at com.example.test.Test04.main(Test04.java:17)</span><br></pre></td></tr></table></figure><p>为什么会抛出空指针异常呢，我相信聪明的小伙伴们已经知道了原因了，那就是因为”a == b”实际上是”a == b.intValue()”,而我们的b为null，这就导致了空指针异常的发生。虽然我们直接写出来对比很直观，但是在写项目的时候如果直接使用==来比较int和Integer可能就会忘了Integer为null的情况，若是通过测试上线后发现问题，那就是个惨痛的教训了。</p><p>因此，我个人建议使用equals来比较int和Integer，因为在这之前我们必然要考虑到Integer等于null的情况，避免了跳进坑里面。同时，建议大家项目中的POJO类都使用包装类型而不是基本数据类型，因为有的时候需要用null来表示一些异常情况。比如说股市的涨幅情况，如果出了问题导致没有获取到这个数值，使用Integer我们能使用-来表示获取失败，而如果是int，经过序列化之后获取的则是0，那显然是一个错误的值。</p><p>然后，一个小伙伴说，他们项目组刚遇到这个问题，并且还放到公司的wiki上面去了。我相信通过上面的解释，大家应该都能知道为什么需要加三目表达式了吧。<br><img src="https://i.loli.net/2019/06/17/5d076c3d17f7525889.png" alt></p><h2 id="通过bug我们学习到了什么"><a href="#通过bug我们学习到了什么" class="headerlink" title="通过bug我们学习到了什么"></a>通过bug我们学习到了什么</h2><p>其实，这个bug我们大家都能避免的。因为Integer的装箱和拆箱机制大家应该都是知道的，这个知识点就和基础类型的隐式装换一样烂熟于心了。可是为什么还是会掉进这个陷进里面去呢，我想还是太大意，没有去深入思考。我们都知道Integer和int比较会有拆箱操作，却没有认真的去思考java是如何拆箱的，知其然却不知其所以然，最终导致错误的发生。</p><p>其实Integer这个类是有很多可以学习到的知识点，所以我建议大家可以去看看这个的源码。最后，对于每一个知识点，我们都应该知其然并知其所以然，应该发散自己的思维，通过现象看本质。这样我们才能在工作中完美的避开那些隐蔽的坑。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 10:35:48 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前
      
    
    </summary>
    
      <category term="java" scheme="http://gpdstudy.club/categories/java/"/>
    
    
      <category term="integer" scheme="http://gpdstudy.club/tags/integer/"/>
    
  </entry>
  
  <entry>
    <title>github配置ssh秘钥报错Permission denied (publickey)</title>
    <link href="http://gpdstudy.club/2019/06/16/github-permission/"/>
    <id>http://gpdstudy.club/2019/06/16/github-permission/</id>
    <published>2019-06-15T16:34:31.000Z</published>
    <updated>2019-06-17T11:17:34.578Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 10:35:48 GMT+0800 (GMT+08:00) --><h2 id="SSH报错Permission-denied-publickey"><a href="#SSH报错Permission-denied-publickey" class="headerlink" title="SSH报错Permission denied (publickey)"></a>SSH报错Permission denied (publickey)</h2><p>以前一直使用的Ubuntu系统，所以使用配置ssh秘钥连接github一直没有出现什么问题。但是今天偶然在Windows系统下给github配置一个秘钥，令人惊奇的事情发生了。github一直报错Permission denied (publickey)，我仔细的检查了下我的.ssh目录，我的秘钥赫然躺在文件夹中。<br><img src="https://i.loli.net/2019/06/16/5d0518fe41dcd69999.png" alt="ssh文件夹"><br>当时我的内心是崩溃的，what the f**k，果然还是Linux大法好，什么破Windows，净出些幺蛾子。但是问题出来了，总是要去解决吧.于是Github搜了一圈下来，发现<a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#adding-your-ssh-key-to-the-ssh-agent" target="_blank" rel="noopener">github帮助</a>里面有一篇关于这个描述。按照以下步骤即可解决报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line"><span class="comment"># 也可以换成下面的命令,两个效果一样</span></span><br><span class="line"><span class="comment"># $ ssh-agent $SHELL</span></span><br><span class="line"></span><br><span class="line">$ ssh-add ~/.ssh/y</span><br><span class="line">Enter passphrase <span class="keyword">for</span> /c/Users/Administrator/.ssh/y:</span><br><span class="line">Identity added: /c/Users/Administrator/.ssh/y (648276765@qq.com)</span><br><span class="line"></span><br><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi xxx! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>但是，我们怎么能只满足于怎么解决呢，于是我就开始了研究之路，通过搜索看了不少博客，了解了大致的原因。</p><h3 id="SSH-agent"><a href="#SSH-agent" class="headerlink" title="SSH agent"></a>SSH agent</h3><blockquote><p>ssh-agent命令是一种控制用来保存公钥身份验证所使用的私钥的程序。在Linux中ssh-agent 在X会话或登录会话之初启动，所有其他窗口或程序则以客户端程序的身份启动并加入到ssh-agent程序中。通过使用环境变量，可定位代理并在登录到其他使用ssh机器上时使用代理自动进行身份验证。<br>其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add命令将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。<br>另外如果您的私钥使用密码短语来加密了的话，每一次使用 SSH 密钥对进行登录的时候，您都必须输入正确的密码短语。而 SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候提供给您的 SSH 客户端。这样子，您就只需要将私钥加入 SSH agent 缓存的时候输入一次密码短语就可以了。这为您经常使用 SSH 连接提供了不少便利。</p><footer><strong>@faner</strong><cite><a href="https://www.jianshu.com/p/1246cfdbe460" target="_blank" rel="noopener">www.jianshu.com/p/1246cfdbe460</a></cite></footer></blockquote><p>通过上面的解释，我们知道我在Ubuntu系统中我们开机就能自动启动ssh-agent，所以我们无需启动ssh-agent就能能直接使用ssh来连接我的github了。但是ssh-agent是无法运行在Windows中的，所以我们需要用git的bash来启动我们的ssh-agent服务，这样才能管理我们秘钥进行ssh操作。同时，通过这个解释，我们还能发现一个很绝望的事情，那就是你每次重新打开一个bash就要再次输入上面的命令才能连接ssh。</p><h3 id="ssh-agent-SHELL和eval-ssh-agent-s-的区别"><a href="#ssh-agent-SHELL和eval-ssh-agent-s-的区别" class="headerlink" title="ssh-agent $SHELL和eval $(ssh-agent -s)的区别"></a>ssh-agent $SHELL和eval $(ssh-agent -s)的区别</h3><ul><li>ssh-agent $SHELL<br>这种方式会在当前shell中启动一个默认shell作为当前shell的子shell，ssh-agent程序会在子shell中运行。$SHELL变量名代表系统的默认shell，如果自己知道系统使用的是哪一种shell也可以直接指定，如ssh-agent bash,ssh-agent csh.退出当前子shell使用exit。</li><li>eval $(ssh-agent -s)<br>eval $(ssh-agent -s)本质上等同于上一个命令，ssh-agent -s只会输出你需要连接的环境变量，因此我们需要加上eval来将这些环境变量加载进来。至于为什么不设置ssh-agent命令本身将环境变量加载进来呢？那是因为在Unix中，进程只能修改自己的环境变量，并将它们传递给子进程。它无法修改其父进程的环境，因为系统不允许它。这是非常基本的安全设计。</li></ul><p>所以，在这两个命令里面大家选一个自己看着顺眼的用就好，虽然解决了使用ssh连接我的github，但是每次都要这么繁琐的步骤。综上，我选择图形化界面。</p><p>那么问题来了，我搞这么就弄清楚这些都是为了啥！！！开个玩笑啦，学无止境，其实还是不亏的，至少又学习到了一点新的知识呢。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 10:35:48 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;SSH报错Permission-denied-publickey&quot;&gt;&lt;a href=&quot;#SSH报错Permission-denied-
      
    
    </summary>
    
      <category term="linux" scheme="http://gpdstudy.club/categories/linux/"/>
    
    
      <category term="shell" scheme="http://gpdstudy.club/tags/shell/"/>
    
      <category term="ssh" scheme="http://gpdstudy.club/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>hello，blog</title>
    <link href="http://gpdstudy.club/2019/06/14/hello-world/"/>
    <id>http://gpdstudy.club/2019/06/14/hello-world/</id>
    <published>2019-06-14T05:05:45.000Z</published>
    <updated>2019-06-17T11:33:22.075Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 10:35:48 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;hello就完事了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 10:35:48 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&amp;emsp;&amp;emsp;hello就完事了&lt;/p&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="hello" scheme="http://gpdstudy.club/categories/hello/"/>
    
    
      <category term="hello" scheme="http://gpdstudy.club/tags/hello/"/>
    
  </entry>
  
</feed>
