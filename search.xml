<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>new ArrayList&lt;&gt;() 与  new ArrayList&lt;&gt;(0)有什么区别。</title>
    <url>/posts/arrayList-one/</url>
    <content><![CDATA[<p>无用知识点系列一：new ArrayList&lt;&gt;() 与 new ArrayList&lt;&gt;(0)有什么区别。</p><a id="more"></a><h3 id="ArrayList中的两个空数组"><a href="#ArrayList中的两个空数组" class="headerlink" title="ArrayList中的两个空数组"></a>ArrayList中的两个空数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ArrayList的源码中，分别有两个空数组对象 EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，他们的区别是在于有参构造使用 EMPTY_ELEMENTDATA 而无参构造则使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA。在现在，你可能会觉得这玩的什么蛇皮操作，为什么不统一改成 EMPTY_ELEMENTDATA 或者 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 呢，这样操作肯定是有它的道理，我们继续往下看。</p><h3 id="空数组作用解析"><a href="#空数组作用解析" class="headerlink" title="空数组作用解析"></a>空数组作用解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// list内部存储的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 默认扩容容量</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个是用于 fast-fail(快速失败)，非 Iterator 迭代若是使用了增删改操作</span></span><br><span class="line">    <span class="comment">// modCount 会递增导致和迭代时保存的 expectedModCount 不一致而抛出异常。</span></span><br><span class="line">    modCount++; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看看扩容的逻辑： ==oldCapacity + (oldCapacity &gt;&gt; 1)== 。说明容器扩容并非 1.5 倍，因为没有小数位，所以当尾数不为 0 的话，就相当于舍去了 0.5，所以扩容为 1.5 倍舍去余数。至于为什么我感觉大家二进制都会，就不多叭叭了。</p><p>接下来是 add 方法，add 的时候，elementData 等于 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的时候，是会直接给数组扩容成 10 的大小，如果是 EMPTY_ELEMENTDATA 则不做处理，直接扩容成了 1。</p><p>由此可得：</p><ol><li>如果是无参构造的话，容器的容量为：0、10、15、22、33 …</li><li>如果是有参构造且参数为 0，容器的容量为：0、1、2、3、4、6、9、13 …</li></ol><p>我们会发现无参构造容器的大小只需要一次扩容就能到 10，而有参构造且参数为 0 的时候，需要七次才能突破 10 的大关。为什么作者这么设计呢？我觉得可能是作者考虑到了有这么一种场景：集合包含的元素不确定，但基本数量都会小于 10，这时使用有参构造且参数为 0 则可以大量的节省内存。</p><p>假设我们有个百万级别并发访问的api，返回的数组都是两三个，这时候用有参为 0 的构造方法，则可以节省 (10 - 2) * 10 000 个数组空间，四舍五入相当于一个亿。</p><p>好吧，我真不知道这个设计有啥用，我猜想也没有几个人会用这种有参构造方法吧。</p><h3 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h3><p>今天的每天一个没用知识点结束，是不是学完感觉到浪费了两分钟时间，每天一个知识点，一年就是 365 * 2 / 60 = 12 个小时，坚持一年就浪费了半天时间，离废物又能更近一步了。</p>]]></content>
      <categories>
        <category>每天一个没用知识点</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用只支持http的七牛云CDN免费实现全站https</title>
    <url>/posts/bloghttps/</url>
    <content><![CDATA[<p>本篇博客主要讲解了用七牛云CDN实现全站https</p><a id="more"></a><blockquote><p>事先声明：此方法适用于拥有自己的服务器，能够安装nginx，因为本篇博客nginx起到关键作用</p></blockquote><h2 id="https的意义"><a href="#https的意义" class="headerlink" title="https的意义"></a>https的意义</h2><p>HTTPS主要通过在SSL上传输数据来区分HTTP，确保传输的数据在传输过程中被加密，只有相应站点服务器或用户浏览器接收时才能被解密，HTTPS通过这种方式避免了第三方拦截。同时，HTTPS提供可信的服务器认证，这是一套黑客不能随意篡改的认证信息，使相关用户确定他们正与正确的服务器通信。</p><h2 id="全站https的初心"><a href="#全站https的初心" class="headerlink" title="全站https的初心"></a>全站https的初心</h2><p>一开始博主的博客是搭载在github上的，可是因为github是国外的IP，加载及其的慢，即使用了CDN也无济于事。正好博主在去年学习Linux的时候趁着大四学生最后一年在腾讯云买了一台学生服务器，于是将博客搬到服务器上了。而本人久闻七牛云大名，所以CDN使用得是七牛云的免费10G。因为我的博客也没什么流量，一个月顶破天我自己访问能不能过百兆是个问题，所以肯定够用的(小声比比：希望我的博客以后访客能上来)。搬到服务器上的时候并没有https，但是想着现在证书都是免费颁发，而且https也是安全的象征，现在的网站基本都使用了https。再说，google浏览器会给https一把小锁，看着别人的https上面有把小锁，这感觉都爽歪歪鸭.再看看自己，网页啥都没。得，为了这把锁，我今天也得给他来个全站https了。<br><img src="https://cloud.ovvow.com/static/images/https%E5%AE%89%E5%85%A8%E6%A0%87%E5%BF%97.png" alt="https网页上的标志"></p><h2 id="实操开始"><a href="#实操开始" class="headerlink" title="实操开始"></a>实操开始</h2><h3 id="申请ssl证书"><a href="#申请ssl证书" class="headerlink" title="申请ssl证书"></a>申请ssl证书</h3><p>既然要全站https那必不可少的是申请证书了，因为博主域名是在腾讯云买的，所以是直接在腾讯云管理平台申请的ssl证书，选择自动验证几分钟就把证书颁发下来了，我们直接点击下载将证书下载过来。解压之后会有四个文件夹，因为我们用的nginx，所以只需要nginx文件夹下面的bundle.crt和.key两个文件，至于外层的csr我们不需要用到。</p><h3 id="部署nginx并且开启https监听"><a href="#部署nginx并且开启https监听" class="headerlink" title="部署nginx并且开启https监听"></a>部署nginx并且开启https监听</h3><p>因为本人最近在学习docker，并且docker的容器管理实在是方便，所以是用的docker拉取nginx镜像以容器的方式启动nginx。docker入门学习的话可以去菜鸟联盟看一看，我觉得讲解的还是很详细的。以下是我docker启动nginx的shell命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -d -p 80:80 -p 443:443 --name myNginx -v /usr/local/nginx/www:/usr/share/nginx/html -v /usr/local/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /usr/local//nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure><p>接下来就是配置nginx的conf文件了，首先我们可以开启网页gzip压缩，这样能把我们网页压缩将近一半，提高访问速度。然后就是nginx配置监听443端口进行证书加密的操作了。以下是我的部分配置文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>设定http服务器</span><br><span class="line">http &#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include       mime.types;</span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如</span><br><span class="line">果图片显示不正常把这个改 成off。</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #防止网络阻塞</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    #开启gzip压缩输出</span><br><span class="line">    gzip  on;</span><br><span class="line">    #最小压缩文件大小</span><br><span class="line">    gzip_min_length  1K;</span><br><span class="line">    ##压缩缓冲区</span><br><span class="line">    gzip_buffers     4 8k;</span><br><span class="line">    ##压缩类型</span><br><span class="line">    gzip_types       text/* text/css text/plain application/javascript application/x-javascript application/xml application/json image/jpeg image/png image/gif application/octet-stream;</span><br><span class="line">    ##压缩级别 1-9 1最快 9最慢</span><br><span class="line">    gzip_comp_level  9;</span><br><span class="line">    ##压缩通过代理的所有文件</span><br><span class="line">    gzip_proxied     any;</span><br><span class="line">    ##vary header支持</span><br><span class="line">    gzip_vary        on;</span><br><span class="line">    ##压缩版本（默认1.1，前端为squid2.5使用1.0）</span><br><span class="line">    gzip_http_version 1.1;</span><br><span class="line">    </span><br><span class="line">    # 监听https请求并配置证书</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name ovvow.com; #填写绑定证书的域名</span><br><span class="line">        ssl_certificate /var/log/nginx/ssl/1_xxx_bundle.crt; #证书文件名称</span><br><span class="line">        ssl_certificate_key /var/log/nginx/ssl/2_xxx.club.key; #私钥文件名称</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照这个协议配置</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #请按照这个套件配置</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">        index        index.html;</span><br><span class="line">        error_page  404 /404.html;</span><br><span class="line">        location ~ .*\.(gif|css|js|jpg|jpeg|png|ico|webp)$ &#123;</span><br><span class="line">            valid_referers none blocked ovvow.com blog.gpdstudy.clu    b;</span><br><span class="line">            if ($invalid_referer) &#123;</span><br><span class="line">                return 404 /404.html;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 将http请求重定向到https</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name ovvow.com;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 配置CDN支持https访问</span><br><span class="line">    server &#123;</span><br><span class="line">        listen        443 ssl;</span><br><span class="line">        # 我们博客用来配置CDN的网址</span><br><span class="line">        server_name  qiniuyun.ovvow.com;</span><br><span class="line">        ssl_certificate /var/log/nginx/ssl/1_qiniuyun.ovvow.com_bundle.crt;</span><br><span class="line">        ssl_certificate_key /var/log/nginx/ssl/2_qiniuyun.ovvow.com.key;</span><br><span class="line">        location / &#123;</span><br><span class="line">            # 七牛云CDN设置的回源网址</span><br><span class="line">            proxy_pass http://回源设置的域名.ovvow.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上部分都有注释，其中第一部分是配置网页压缩，以提高我们博客的访问速度；第二个则是监听我们的https请求，配置证书加密后跳转到我们博客的主页；第三个是将我们的http请求全部重定向到我们的https上。第四个则是重头戏，这个是我们使用https请求CDN的配置。</p><h3 id="配置原理"><a href="#配置原理" class="headerlink" title="配置原理"></a>配置原理</h3><p>前面的配置不多说相信大家都知道，我就重点说一说第四个吧。我们配置七牛云的CDN时需要绑定一个回源HOST，这个回源HOST需要我们在域名处配置CNAME转到七牛云给我们提供的CDN网址。但是七牛云只支持http请求，如果我们要使用https则需要另行付费。但是我们想一想https的原理就知道，其实这就是经过一层ssl加密数据并进行传输。我们既然无法在七牛云设置https传输数据，那我们自己在请求中间加一层不行吗？于是，我有了这个想法之后参考了第二部分博客实现https的原理。另外申请了一个子域名的ssl，然后通过nginx加密请求之后将反向代理请求到我的CDN域名上获取http资源。结果是令人兴奋的，我的实验成功了。最后说一句，我们这个配置的原理就是<font color="red">利用自己申请的ssl证书来加密我们的请求，再通过nginx反向代理获取我们CDN上的静态资源。<font>这样，我们就能保证我们的资源是经过https加密的。</font></font></p><h2 id="说说薅羊毛"><a href="#说说薅羊毛" class="headerlink" title="说说薅羊毛"></a>说说薅羊毛</h2><p>通过这个示例我发现了一个薅羊毛的方法，我听说国内还有其他的CDN服务商。也就是说，我们可以两边同步我们的资源文件夹，当我们其中一个CDN流量要用完的时候，我们在nginx里面修改配置，将反向代理的网址修改为另一个CDN服务商的回源网址。这样我们无需改变我们博客的任何位置，就能实现将CDN换源，是不是想想就激动呢？不过我就没这个想法了，七牛云10G我相信我能用一年，更不要说每个月都给10G，我就懒得薅这个羊毛了，缺流量的站长可以薅一下。</p><h2 id="说说踩过的坑"><a href="#说说踩过的坑" class="headerlink" title="说说踩过的坑"></a>说说踩过的坑</h2><p>（1）因为以前一直是监听的80端口，通过不同的域名来跳转我的项目。昨天启动nginx的时候忘了映射443端口，导致后续http重定向到https的时候一直无法访问，查看nginx配置半天也没发现端倪。最后查看防火墙端口的时候发现我的443端口没有被监听，遂恍然想起自己只映射了80端口并未映射443端口。希望大家以我为戒，不要犯这种低级问题，<font color="red">要记住想要监听端口就得把服务器的端口映射给容器。<font></font></font></p><p>（2）docker容器内配置文件的地址只能访问到容器内部的地址，并不能访问到服务器地址，开始把秘钥放在了服务器的nginx/conf文件夹下面，结果发现无法访问。后来索性在logs下新建了ssl文件夹存放我的证书，因为我的logs文件夹映射了容器/var/log/nginx/文件夹，所以通过此路径能找到我的ssl证书。</p><p>（3）在配置的时候，我并不知道一个域名对应一个证书，当时以为配置了主站所有的子域名都可以使用这个证书，所以在设置”qiniuyun.ovvow.com”域名加密反向代理到七牛云回源网址的时候虽然能够代理成功，但是却被Google拦截了，导致所有的CDN请求直接被阻挡加载不进来。如下图。<br><img src="https://cloud.ovvow.com/static/images/%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="错误设置证书"><br><img src="https://cloud.ovvow.com/static/images/https%E8%AF%81%E4%B9%A6%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF.png" alt="博客无法加载静态资源"><br>最后仔细一看发现颁发的证书与实际访问的网址不一样，百度了一下发现每一个子域名都得设置一个证书。于是又申请了两个证书在nginx配置完成之后成功加载资源。<br><img src="https://cloud.ovvow.com/static/images/https%E4%BB%A3%E7%90%86%E6%88%90%E5%8A%9F.jpg" alt="代理成功返回的图片链接"><br><img src="https://cloud.ovvow.com/static/images/cdn%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87.jpg" alt="实际被访问的链接"></p><p>虽然在配置的过程是痛苦的，但是最后实现了自己的想法，还是蛮开心的。</p>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习书籍推荐</title>
    <url>/posts/book-recommend/</url>
    <content><![CDATA[<p>本篇博客主要推荐了一些java书籍</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>俗话说，万事开头难，哪行哪业都是如此，只有掌握了学习的基础以及方向，我们才能持续性学习下去。如果开始就像无头苍蝇一般找不到入口，随便乱撞，这个也学那个也学，缺乏系统性的学习,看似什么都会点，但用起来又啥都不会，最终学习的兴趣被磨灭殆尽。因此，这篇博客主要是总结了一下本人学习的路线，给大家一个学习的建议。</p><h3 id="入门阶段"><a href="#入门阶段" class="headerlink" title="入门阶段"></a>入门阶段</h3><h4 id="1-《java从入门到精通》"><a href="#1-《java从入门到精通》" class="headerlink" title="1.《java从入门到精通》"></a>1.《java从入门到精通》</h4><p>这一阶段可谓是百花绽放，我相信大家肯定都有听过或者看过下面这本书：<br><img src="https://cloud.ovvow.com/static/images/java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83.png" alt="java从入门到放弃"><br>对不起，拿错书了，是这本：<br><img src="https://iknow-pic.cdn.bcebos.com/ac345982b2b7d0a29ff5e892cfef76094b369a85" alt="java从入门到精通"><br>其实，这本书我是不推荐看的，这本书名字取得倒是很好，但你要真看过这本书你就知道了。这本书讲的东西是很基础的，并且用了大量的示例来讲解，对于科班同学来说不是那么有用。还有就是，这本书他虽然讲的是基础，但是不配合光盘学习他很多东西都没有介绍就用了，比如说控制台的输入语句。这本书也不是我的入门书籍，但是看过这本书，就结论来说，这本书也就是大学JAVA基础的知识点。如果你是非科班或者你还没上JAVA基础课就想学习java，那这本书的确可以一看，但就学习效率来说，耗时长，效率低。</p><h4 id="2-《Head-First-Java（第二版·中文版）》"><a href="#2-《Head-First-Java（第二版·中文版）》" class="headerlink" title="2.《Head First Java（第二版·中文版）》"></a>2.《Head First Java（第二版·中文版）》</h4><p>这本书是非常好的一本书，很适合初学者，其实任何国外书籍首先推荐的都应该是英文版，因为受翻译以及专业术语的限制，中文版或多或少在翻译的时候会出现失真的情况，英文好的同学可以看看英文版。这本书的优点在于，作者其实也是研究心理学的大佬，所以书籍是以图文版呈现给大家，旨在让大家能够快乐学习，并并且其教学模式为：提出需求，设计初步解决方案，发现不足遇到问题，引入知识点，升级解决方案弥补不足解决问题。此书注重理解，深入浅出，知行合一，阅读体验极好。</p><h4 id="2-《Head-First-设计模式（中文版）》"><a href="#2-《Head-First-设计模式（中文版）》" class="headerlink" title="2.《Head First 设计模式（中文版）》"></a>2.《Head First 设计模式（中文版）》</h4><p>这本书和上一本都是同一个作者，不同的是这本书讲的是设计模式，作为一个合格的<del>码农（划掉）</del>程序员，还是有必要知道一些设计模式，这本书深入浅出讲解了一些常用的设计模式，足以满足日常的工作需求。</p><h4 id="4-《Java核心技术》"><a href="#4-《Java核心技术》" class="headerlink" title="4.《Java核心技术》"></a>4.《Java核心技术》</h4><p>《Java核心技术》有两本，一本是《java核心技术 卷1 基础知识》，另一本是《Java核心技术卷 2 高级特性》。这是一本官方教程，而且又是翻译版，所以可能内容有些书面化，第一次接触java的人可能会感觉有点不适应，但其实都是一些比较好理解的东西，并且其中还有很多官方的示例，对阅读和理解还是有一定的帮助的。在卷1中，java语言的基础知识以非常体系化的方式呈现给大家，是一本不错的教学书籍。毕竟官方推荐，必属精品了。</p><h3 id="进阶阶段"><a href="#进阶阶段" class="headerlink" title="进阶阶段"></a>进阶阶段</h3><h4 id="1-《java编程思想-第四版》"><a href="#1-《java编程思想-第四版》" class="headerlink" title="1.《java编程思想 第四版》"></a>1.《java编程思想 第四版》</h4><p>《java编程思想》这本书都快被奉为java圣经，其受到大众的推崇是有一定的道理的。但是在入门推荐的时候，有很多人推荐新人看这本书，导致这本书也被人疯狂吐槽。这本书个人觉得的确不适合当做入门书籍来看，因为这本书知识点比较深，对语言的剖析也比较深，各种专业术语频出，其中还配合了设计模式，加上又是翻译版。那酸爽，就是看天书，不仅十分枯燥，你还可能看不懂（对，就是本人没错了）。因此还是建议大家先把入门阶段书籍看完，然后具备一定基础的时候在看，说真的这本书每隔一段时间再看一遍都能有不同的新收获。<br><font color="red">当然，java编程思想是有第五版的，名字叫《on java 8》。新增了流和函数式编程的知识点，但因为知识点太多，成书的话太厚，因此只在作者博客上更新。当然，国内也有很多优秀的同学将博客翻译并上传到了github上，gitbook地址为：<a href="https://lingcoder.github.io/OnJava8/" target="_blank" rel="noopener">on java 8</a></font></p><h4 id="2-《Java并发编程的艺术》"><a href="#2-《Java并发编程的艺术》" class="headerlink" title="2.《Java并发编程的艺术》"></a>2.《Java并发编程的艺术》</h4><p>这本书不是很适合作为 Java 并发入门书籍，需要具备一定的 JVM 基础。我感觉有些东西讲的还是挺深入的，推荐阅读。</p><h4 id="3-《java并发编程实战》"><a href="#3-《java并发编程实战》" class="headerlink" title="3.《java并发编程实战》"></a>3.《java并发编程实战》</h4><p>这本书和并发编程的艺术相比，更侧重于实践，推荐和并发编程的艺术一起看。</p><h4 id="4-《深入理解-Java-虚拟机》"><a href="#4-《深入理解-Java-虚拟机》" class="headerlink" title="4.《深入理解 Java 虚拟机》"></a>4.《深入理解 Java 虚拟机》</h4><blockquote><p>作为一位Java程序员，你是否也曾经想深入理解Java虚拟机，但是却被它的复杂和深奥拒之门外?没关系，本书极尽化繁为简之妙，能带领你在轻松中领略Java虚拟机的奥秘。本书是近年来国内出版的唯一一本与Java虚拟机相关的专著，也是唯一一本同时从核心理论和实际运用这两个角度去探讨Java虚拟机的著作，不仅理论分析得透彻，而且书中包含的典型案例和最佳实践也极具现实指导意义。</p></blockquote><p>这本书算是对JVM讲解最详细的一本书了，不但告诉了你JVM如何运行，同时也有大量的故障排查内容，绝对是JVM入门不二之选了。</p><h4 id="5-《Effective-Java中文版-第2版-》"><a href="#5-《Effective-Java中文版-第2版-》" class="headerlink" title="5.《Effective Java中文版(第2版)》"></a>5.《Effective Java中文版(第2版)》</h4><p>这本书介绍了在java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。<br>本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。</p><h3 id="工具类书籍"><a href="#工具类书籍" class="headerlink" title="工具类书籍"></a>工具类书籍</h3><h4 id="《maven实战》"><a href="#《maven实战》" class="headerlink" title="《maven实战》"></a>《maven实战》</h4><p>Maven是Java Web开发中不可缺少的一部分（不过现在gradle貌似正在兴起，后期学习一下），这本书内容全面而系统，Maven的原理、使用方法和高级应用尽含其中；注重实战是本书的另一个特点，不仅在各个知识点都辅有大量的小案例，而且还有一个综合性的案例贯穿全书。</p><h4 id="《‎Redis开发与运维》"><a href="#《‎Redis开发与运维》" class="headerlink" title="《‎Redis开发与运维》"></a>《‎Redis开发与运维》</h4><p>这本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。</p><h4 id="《MySQL技术内幕：innodb存储引擎》"><a href="#《MySQL技术内幕：innodb存储引擎》" class="headerlink" title="《MySQL技术内幕：innodb存储引擎》"></a>《MySQL技术内幕：innodb存储引擎》</h4><p>这本书首先宏观地介绍了MySQL的体系结构和各种常见的存储引擎以及它们之间的比较；接着以InnoDB的内部实现为切入点，逐一详细讲解了InnoDB存储引擎内部的各个功能模块的实现原理，包括InnoDB存储引擎的体系结构、内存中的数据结构、基于InnoDB存储引擎的表和页的物理存储、索引与算法、文件、锁、事务、备份与恢复，以及InnoDB的性能调优等重要的知识；最后对InnoDB存储引擎源代码的编译和调试做了介绍，对大家阅读和理解InnoDB的源代码有重要的指导意义。而且这本书每一章都是一个知识点，可以随意从任意一章开始看起，在项目中需要用到哪些可以优先学习这部分知识。</p><h4 id="《深入理解kafka》"><a href="#《深入理解kafka》" class="headerlink" title="《深入理解kafka》"></a>《深入理解kafka》</h4><p>作为消息队列来说，kafka和mq都是不错的选择，并没有哪一个最好，只有最合适的。作为kafka的学习，这本书阐述了Kafka中生产者客户端、消费者客户端、主题与分区、日志存储、原理解析、监控管理、应用扩展及流式计算等内容，是本不错的书籍。</p><h3 id="其他书籍推荐"><a href="#其他书籍推荐" class="headerlink" title="其他书籍推荐"></a>其他书籍推荐</h3><p>当然，以上只是针对于java书籍的推荐，但身为程序员，不能只狭隘的学习一门语言，还得对计算机原理和算法以及网络有一定的了解，以下是一些推荐的书籍。</p><ul><li>《TCP/IP卷一》</li><li>《计算机网络》</li><li>《算法 第四版》</li><li>《剑指offer》</li><li>《重构 改善既有代码的设计》<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3>其实，程序=算法+数据结构。因此，对于算法这方面的知识点永远不要停下学习的脚步，或许你在应用开发中很少使用到算法。但实际，算法越强便越不可替代。举个例子，现在抖音已经抢占了国内短视频的大部分流量，其依靠的就是视频流推荐算法，根据用户对各种视频的点赞、停留时间等等数据，计算出用户喜欢的视频类型并加以推荐，从而抢占了短视频最大的蛋糕。<font color="red">所以，当你男（女）朋友手机里面有抖音，拿TA的手机刷十几条视频，如果全是小哥哥（小姐姐），那不用怀疑，即使TA没点赞，TA必然也是天天看的。最后，大家可以行动起来了，祝君好运^.^。</font></li></ul>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>梦</title>
    <url>/posts/dream/</url>
    <content><![CDATA[<blockquote><p>每一个童年，都拥有一场年少的梦，每一场梦醒，都预示一个少年的凋亡。</p></blockquote><a id="more"></a><h3 id="相识"><a href="#相识" class="headerlink" title="相识"></a>相识</h3><p>在少年東的那条街上，有着另一个与少年相差不到一岁的小孩，他叫做诚，因为彼此的父母相识，加之两人又是同班同学，两位少年郎很快就熟络了起来。</p><p>“请问老师，老鼠怎么说？”在一节英语课上，传来東那稚嫩的少年音。“mouse！”，老师十分欣慰，在一群贪玩的学生中，终于有愿意听课的小孩。正当欣慰之时，只见少年对着同桌就是一顿疯狂输出：“mouse，mouse，你这只mouse。”。原来因为诚属鼠，所以東故意问老师老鼠的英文，用以给诚取外号。“老师，冬瓜怎么说呢！”，诚不甘示弱。只是老师摇摇头，再也不理会那两个少年，自顾自的讲起了课。然而，台下只有两个少年的打闹，以及一群无心上课贪玩的小孩。</p><p>时间一直在流逝，两个少年每天都在早晨互相当对方的闹钟，在学校也一直互相陪着，甚至在课外活动的时候，别的小孩早已玩起了踢房子、跳绳、捉寨等游戏的时候，只有这两人，一直围着那几亩的校园边聊边转，就这样度过了一年又一年。甚至连如今的我都不知道，为何能够聊这么久。</p><p>東和诚，两位少年如影随行，除了吃饭睡觉，東都会跑到诚的家中。诚的父母与東比，则严格的多，每天都有要背的英文单词，每天都有布置的作业。在诚做作业的时候，東就坐在那，慢慢的等待，而诚做完作业的时候，便是两人的娱乐时间，他们会比扔飞镖，尽管诚房间的门已经被扎的千疮百孔，他们依旧乐此不彼；有时诚的母亲会拿出他的手机，他们便玩着叮当猫的游戏，一人一条命，在两人无尽的互相嘲讽中，时间就这样悄然的流逝着。</p><p>那是一个秋季，也是一个大丰收的季节。在傍晚放学回家的路上，有着一片稻田，现在那田中只剩下被打完稻谷的稻秆。一群少年在其中玩着摔跤的游戏，東和诚也混入其中。只见在那稻田中，两人筋疲力尽的躺在稻草中，突然，東对着诚说：“按辈分，你该叫我叔叔，我想，等我老了，你孙子叫我太爷爷，那是多好玩的一件事呀。”“别做梦了，死冬瓜，你连我都打不过，你还想我孙子叫你太爷爷，顶多叫爷爷！”诚奋力反击道。“那要不要试试，我干趴你？”“就你？”“起来，我们干一场”“来就来，谁怕谁”。于是，在一场吵闹中，两人又起身打闹起来了。夕阳慢慢的落下，少年的影子也慢慢的被拉长，似乎也在祝福着少年们的友谊能够天长地久。</p><h3 id="分别"><a href="#分别" class="headerlink" title="分别"></a>分别</h3><p>有时候我们会感受到时间真的短暂，总想它过得慢点，但时间是公平的亦或是说它是自私的，它并不由你的感受而动，总是随着自己的意愿不断的向前，向前，永无止境，即使它也不知道，自己的终点在哪。而我们，也只能在它无情的推动下，被迫的走下去。</p><p>时间的指针一转眼就已经拨动到少年五年级的时候，两人如往常一般在诚的家中玩耍，只见诚略带哭腔的说道：“我要去湖南读书了。”“那你还会回来吗？”東双手捏着衣角无所适从的说道。“我不知道，应该会回来吧”诚低下了头，声音夹杂着一丝迟疑。“我等你！”東眼眶莹润，“我们说好的，在老了的时候，躺在摇椅上对着自己的孙子们讲着我们的故事。”“嗯！”回复稚嫩但却坚定。</p><p>果然，没过多久，诚走了，他家的大门紧闭着，隔绝着他们家与街道，同时也隔离了東与诚。</p><p>放学路上，東又一次经过了诚家门口，迎接的依旧是那一把铁将军。其实，東和诚并不顺路，東往诚家里走还要绕一段，但是在过去几年，東已经养成了往诚家过的习惯。即使诚已经走了，这个习惯依旧没有改变，因为東一直希望有一天，在放学归来的时候，迎接他的不再是那一把铁将军，而是诚那张稚嫩的笑容。</p><p>在诚离去后，東的期末成绩单上，少了一段“上课爱说话”的评语，这是東从入学起，每一学期都印刻在成绩单的评语。这段评语结束，東并未觉得开心，因为随之结束的，还有一段東不能遗忘的回忆。</p><h3 id="再会"><a href="#再会" class="headerlink" title="再会"></a>再会</h3><p>时间一晃，東已经在读初二，如往常一般，東在中午放学回家的路上看向了诚家的大门，然而今日依旧是一把铁将军守门。正当東转头回家的时候，只见诚的表妹一蹦一跳的跑过来说：“你找我哥哥是吧，他今天回来了，现在在我奶奶家，下午就回回来。”那一瞬间，各种情绪涌上心头，東已经描述不出这种感觉，但有一种感觉是不会错的，那就是東很开心。</p><p>整个下午，東都没有听过课，不过这也是常态，東从初二就没有听过课。那是正值豆蔻年华，懵懂的少年用自己发育不全的大脑定义出了”酷”。上课和老师对着干——酷；考试考倒数第一——酷；喊着一群一样大脑发育不全的少年打架——酷。在这么酷的思维下，少年结交了一群“志同道合”的朋友，为了心中的酷，不断的犯下一个又一个名为“叛逆”的罪。虽然東交了不少朋友，但始终忘不了那一个与他一起在夕阳下，宣誓着老年一起躺着摇椅共诉往事的少年。</p><p>诚的确回来了，因为中考要回本地考试的原因，诚要在我们中学读书并参与中考。而诚在湖南读的初一无效，需要重新在我们中学重读，于是那一年，诚初一，東初二。但这并没有影响到東和诚的感情，他们恢复了那一段如影随形的日子，基本只要下课，两人就在一起，那是少年话题最多的时刻，游戏也是永远不腻的话题。当然，期间東一直都在做着他认为酷的事情，把该得罪的老师都得罪了一个遍。</p><p>“我要留级！”東对父母说道。東的父母开心坏了，他们以为東开窍了。于是开学的时候，他们带着東去报道，准备给東办留级。然而東的入学并不顺利，他连正常初三开学都难，因为東在学校已经成为了典型的负面例子，没有人愿意收他，也是，没有人愿意收一颗“老鼠屎”。而東的父亲，为了让他顺利入学，放下面子各种求人帮忙。東的父亲是个爱面子的人，这是他父亲这一生，第一次放下自己的脸面去求人，然而，为了却不是自己。</p><p>幸好東虽然很皮，但和以前的体育老师玩的很好，因为那位老师并不会摆架子，也愿意让東去皮。刚好他被安排当初二一个班的班主任，東的父亲找到他的时候，他知道是東之后，收留了他。同时他们也约法三章，東再也不调皮捣蛋，好好学习。</p><p>東终于留级了，因为同一个年级在一层楼，于是東和诚每天下课就在一起聊天，他们谈游戏动画，也谈梦想未来。一切似乎都朝着美好的未来发展着。</p><h3 id="兄弟阋墙"><a href="#兄弟阋墙" class="headerlink" title="兄弟阋墙"></a>兄弟阋墙</h3><p>人生总有一些鸿沟，跨越过去虽然不知道会不会让一切变得更好，但跨不过去，结局却是粉身碎骨。</p><p>因为東和诚太过亲密了，幸好当时还没有搞基这一说，不然这闲言风语可能就出来了。但是，東的行为依然踩到了一些老师的尾巴。终究还是有那么一天，老师被踩疼了。</p><p>東被班主任叫到了办公司，“你最近和诚走的太近了”班主任缓缓道，“他们班主任向我反映，你影响到了他的正常学习，他是要冲击重点高中的，现在排名已经有所落后，你不要再影响他了。”東听完，大脑已经一片空白。“虽然你一直很调皮，但是我相信你。你只要认真学习，一定也能考上重点高中的，只是现在他们班主任给我反映了，我还是有责任和你说一声的。”班主任开始安慰道。</p><p>東已经不记得是怎么走回教室的，他的内心开始涌出的悲伤，慢慢的愤怒、不甘、嫉妒等各种情绪直冲心脏，仿佛这一刻，要将東给吞噬。“为什么，我不配和他玩吗？”“居然看不起我，我就这么差劲吗？””凭什么，就凭诚比我优秀我就该被这样对待吗？”“对，老师说的对，我并不差，我并不差！！我一定要证明给他们看，没有我的影响，我也会比诚更加的优秀，对，我一定会超越他。”此刻，東已经失去了理智，已然被涌现的情绪给吞没，慢慢的沉入其中。年幼的他并不知道如何面对这种事情，不服输的他开始对诚产生了敌意，他觉得，都是因为诚成绩比好他才会导致这一切的发生。一颗扭曲的心，就这样怦然跳动着，愈来愈烈。</p><p>诚如往常一般来找東，被東以学习给拒绝了，早上東再也不去诚家中喊他起床了，晚上也不在放学的时候去诚家中玩了，而诚也在東家中喊了无数次東的名字却被告知已经上学而慢慢不再找東了。是的，東在慢慢的疏远诚，因为他想证明给诚的班主任看，他会比诚更优秀，同时也是对自己班主任信任自己的一个回报。</p><h3 id="心碎"><a href="#心碎" class="headerlink" title="心碎"></a>心碎</h3><p>東的成绩越来越好了，即使是東自己都开始怀疑，这究竟是不是一场梦。时间又发挥着它应有的作用，这一群少年，不知不觉已经被推到了中考的边缘线上了。東很紧张，因为这是東想要证明自己的战场，想要和诚决一雌雄的战场。</p><p>随着一声铃声，中考的战场终于结束了，東如战神一般，他相信自己终将会夺得这场战斗的胜利。</p><p>终于到了放榜的那一天，東早早的来到了学校门口，迫不及待的在红纸上找寻着自己的名字。幸运的是，他的名字就这样金灿灿的在前几行，而诚的名字，却被他甩在了后头。東开心的笑了，他证明了自己，他用自己的行动，给那些看轻自己的老师狠狠的删了一巴掌。</p><p>而随着兴奋的散去，突然只听“砰”的一声，東感觉自己的心突然碎了一个角，这个角的碎片携带者東和诚一幕幕的过往碎裂开了。東哭了，他不知道自己是怎么了，他只是觉得自己很难受，他拼命想去抓住那些碎片，但是東却发现，自己无论如何也够不着，只能眼巴巴的看着他不断的下坠，下坠，最终消失的无影无踪。</p><p>東觉得，自己再也找不回那缺失的一角了，東开始在想，自己是不是真的错了，自己到底得到了什么，自己到底失去了什么。東后悔了，但他后悔也没有用，碎裂的一角，无论如何也无法修补了。東此刻才发现了，随着那一角的碎裂，从前那个在夕阳下许诺一起老年躺在摇椅中的少年随之而死，而随少年消散的，还有那一场终究没有迎来结局的梦。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>故事就此结束，并没有人所期待的完美结局。错过的终究是错过了，犹如破镜不能重圆，自己亲手掐灭的友情，又怎敢期待完好如初。每个人会做着不同的梦，也许是友情，也许是爱情，也许是事业。我只能祝愿着每一个人，做完这一场不会醒的梦，在梦中迎向happy end。</p>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>github配置ssh秘钥报错Permission denied (publickey)</title>
    <url>/posts/github-permission/</url>
    <content><![CDATA[<p>本篇博客主要讲解了github报错Permission denied的解决方法</p><a id="more"></a><h2 id="SSH报错Permission-denied-publickey"><a href="#SSH报错Permission-denied-publickey" class="headerlink" title="SSH报错Permission denied (publickey)"></a>SSH报错Permission denied (publickey)</h2><p>以前一直使用的Ubuntu系统，所以使用配置ssh秘钥连接github一直没有出现什么问题。但是今天偶然在Windows系统下给github配置一个秘钥，令人惊奇的事情发生了。github一直报错Permission denied (publickey)，开始以为是没有秘钥，于是按照下面的步骤生成了秘钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t y -C <span class="string">"youemail@gmail.com"</span></span><br><span class="line"><span class="comment"># 注意，千万别学我，随便给秘钥取名，这是我进坑的一个地方</span></span><br><span class="line"><span class="comment"># ssh-keygen -t rsa  -C "youemail@gmail.com"</span></span><br></pre></td></tr></table></figure><p>但是，生成之后还是报错，我仔细的检查了下我的.ssh目录，我的秘钥赫然躺在文件夹中。<br><img src="https://cloud.ovvow.com/static/images/ssh%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="ssh文件夹"><br>当时我的内心是崩溃的，what the f**k，果然还是Linux大法好，什么破Windows，净出些幺蛾子。但是问题出来了，总是要去解决吧.于是Github搜了一圈下来，发现<a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#adding-your-ssh-key-to-the-ssh-agent" target="_blank" rel="noopener">github帮助</a>里面有一篇关于这个描述。按照以下步骤即可解决报错。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line"><span class="comment"># 也可以换成下面的命令,两个效果一样</span></span><br><span class="line"><span class="comment"># $ ssh-agent $SHELL</span></span><br><span class="line"></span><br><span class="line">$ ssh-add ~/.ssh/y</span><br><span class="line">Enter passphrase <span class="keyword">for</span> /c/Users/Administrator/.ssh/y:</span><br><span class="line">Identity added: /c/Users/Administrator/.ssh/y (648276765@qq.com)</span><br><span class="line"></span><br><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi xxx! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>但是，我们怎么能只满足于怎么解决呢，于是我就开始了研究之路，通过搜索看了不少博客，了解了大致的原因。</p><h3 id="SSH-agent"><a href="#SSH-agent" class="headerlink" title="SSH agent"></a>SSH agent</h3><blockquote><p>ssh-agent命令是一种控制用来保存公钥身份验证所使用的私钥的程序。在Linux中ssh-agent 在X会话或登录会话之初启动，所有其他窗口或程序则以客户端程序的身份启动并加入到ssh-agent程序中。通过使用环境变量，可定位代理并在登录到其他使用ssh机器上时使用代理自动进行身份验证。<br>其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add命令将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。<br>另外如果您的私钥使用密码短语来加密了的话，每一次使用 SSH 密钥对进行登录的时候，您都必须输入正确的密码短语。而 SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候提供给您的 SSH 客户端。这样子，您就只需要将私钥加入 SSH agent 缓存的时候输入一次密码短语就可以了。这为您经常使用 SSH 连接提供了不少便利。</p><footer><strong>@faner</strong><cite><a href="https://www.jianshu.com/p/1246cfdbe460" target="_blank" rel="noopener">www.jianshu.com/p/1246cfdbe460</a></cite></footer></blockquote><p>通过上面的解释，我们知道我在Ubuntu系统中我们开机就能自动启动ssh-agent，所以我们无需启动ssh-agent就能能直接使用ssh来连接我的github了。但是ssh-agent是无法运行在Windows中的，所以我们需要用git的bash来启动我们的ssh-agent服务，这样才能管理我们秘钥进行ssh操作。同时，通过这个解释，我们还能发现一个很绝望的事情，<del>那就是你每次重新打开一个bash就要再次输入上面的命令才能连接ssh</del>。<font color="red">修正，我发现只要秘钥名字是默认的id_rsa就能直接使用，无需通过ssh-agent添加。目前还不知道原因，因为自己这方面知识比较薄弱，所以可能会出现错误，大家有兴趣可以自己去研究一番（修正于2019-6-19）</font>。</p><h3 id="ssh-agent-SHELL和eval-ssh-agent-s-的区别"><a href="#ssh-agent-SHELL和eval-ssh-agent-s-的区别" class="headerlink" title="ssh-agent $SHELL和eval $(ssh-agent -s)的区别"></a>ssh-agent $SHELL和eval $(ssh-agent -s)的区别</h3><ul><li>ssh-agent $SHELL<br>这种方式会在当前shell中启动一个默认shell作为当前shell的子shell，ssh-agent程序会在子shell中运行。$SHELL变量名代表系统的默认shell，如果自己知道系统使用的是哪一种shell也可以直接指定，如ssh-agent bash,ssh-agent csh.退出当前子shell使用exit。</li><li>eval $(ssh-agent -s)<br>eval $(ssh-agent -s)本质上等同于上一个命令，ssh-agent -s只会输出你需要连接的环境变量，因此我们需要加上eval来将这些环境变量加载进来。至于为什么不设置ssh-agent命令本身将环境变量加载进来呢？那是因为在Unix中，进程只能修改自己的环境变量，并将它们传递给子进程。它无法修改其父进程的环境，因为系统不允许它。这是非常基本的安全设计。</li></ul><p>所以，在这两个命令里面大家选一个自己看着顺眼的用就好，虽然解决了使用ssh连接我的github，但是每次都要这么繁琐的步骤。综上，我选择图形化界面。</p><p>那么问题来了，我搞这么就弄清楚这些都是为了啥！！！开个玩笑啦，学无止境，其实还是不亏的，至少又学习到了一点新的知识呢。</p>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JDK1.8的HashMap源码解析三(get和remove以及迭代器)</title>
    <url>/posts/hashMap-three/</url>
    <content><![CDATA[<p>本篇博客主要讲解了HashMap的get和remove和迭代器</p><a id="more"></a><h2 id="相关系列"><a href="#相关系列" class="headerlink" title="相关系列"></a>相关系列</h2><blockquote><p><a href="https://ovvow.com/posts/hashMap-one/#more" target="_blank" rel="noopener">基于JDK1.8的HashMap源码解析一(变量和构造器)</a><br><a href="https://ovvow.com/posts/hashMap-two/#more" target="_blank" rel="noopener">基于JDK1.8的HashMap源码解析二(put和resize操作)</a></p></blockquote><h2 id="HashMap的get操作"><a href="#HashMap的get操作" class="headerlink" title="HashMap的get操作"></a>HashMap的get操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// get方法判断传入key的节点是否存在，存在则返回value值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断entry数组是否有元素，以及当前key的hash所在的bucket是否存在Node</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查第一个Node的key是否和当前key相等,相同则返回头结点</span></span><br><span class="line">        <span class="comment">// 注意，第二个判断明显是可以判断null的，所以1.8并没有对null做特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果首节点不存在查找的key,遍历后续的尾节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 红黑书，跳过。。。</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 循环遍历查找Node节点的key是否与查询的key匹配，匹配则返回</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有包含key的Node</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断HashMap是否包含value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历entry数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个bucket的链表</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="comment">// 判断节点value值是否有包含查找的value</span></span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实HashMap的get方法还是挺简单的。<font color="red">先通过hash计算出key所在的bucket，在通过循环便利其中的Node判断是否包含查找的key，如果找到则返回节点的value值。</font></p><h2 id="HashMap的remove操作"><a href="#HashMap的remove操作" class="headerlink" title="HashMap的remove操作"></a>HashMap的remove操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 删除节点方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除包含key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 判断数组不为空且key所在bucket不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果第一个节点为要移除的节点，记录此节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是红黑树执行此方法</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 循环遍历后续所有尾节点判断是否包含删除的key，找到则记录跳出循环</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 记录当前非删除的节点，因为到了删除的节点就break了，所以一定是删除的节点的上一个节点</span></span><br><span class="line">                    <span class="comment">// 当然，这是要走到这一步，即删除的不是头结点</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 红黑树执行红黑树的删除方法</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果删除的是头节点，则把头结点的下一个节点设为头结点；否则把上一个节点的尾节点指向删除节点的下一个节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 给linkedHashMap留的后门</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 内部操作数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果entry数组不为空，则将数组元素全部清空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的删除方法也很简单。<font color="red">先计算删除的key的hash在哪个bucket，遍历链表记录要删除的节点之后把上一个节点指向要删除节点的下一个节点。</font></p><h2 id="HashMap的迭代器"><a href="#HashMap的迭代器" class="headerlink" title="HashMap的迭代器"></a>HashMap的迭代器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下一返回节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    Node&lt;K,V&gt; current;</span><br><span class="line">    <span class="comment">// 快速失败检测</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line">    <span class="comment">// 当前下标</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// 记录HashMap的内部操作次数</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="comment">// 记录当前的entry数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 拿到第一个有Node的entry下标</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否有下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">// 迭代过程中原entry数组被操作过则快速失败</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="comment">// 没有下一个元素还迭代则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 移动到当前节点的下一节点，如果没有节点再继续寻找entry数组中下一个有节点的下标</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="comment">// 当前节点等于null抛出状态异常</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="comment">// 迭代过程中原entry数组被操作过则快速失败</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        <span class="comment">// 正常情况调用删除节点</span></span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 因为调用删除之后内部操作次数会+1，所以重新赋值内部操作数</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">HashMap的内部迭代器采用fail-fast模式，即快速失败模式。我们可以发现迭代器的方法中，首先判断了”modCount”是否等于内部记录的”expectedModCount”，如果不是，那么直接抛出ConcurrentModificationException。这就说明了，在使用迭代器过程中，我们是无法对HashMap进行remove和put操作的，因为这都会让我们内部的modCount改变导致和记录的expectedModCount不一致。但是我们可以使用迭代器自己的remove方法，因为调用迭代器自己的remove方法会执行删除操作并更新expectedModCount。所以我们一定要注意，不要在迭代过程中直接对HashMap进行remove操作，而应该使用迭代器的remove操作。如果你想在HashMap迭代过程中实现新增，你可以自己继承一个HashMap创建一个自己的迭代器(我并不建议这么做，因为你要解决是否还需要遍历这个节点以及如何实现)</font></p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JDK1.8的HashMap源码解析一(变量和构造器)</title>
    <url>/posts/hashMap-one/</url>
    <content><![CDATA[<p>本篇博客主要讲解了HashMap的变量和构造器</p><a id="more"></a><blockquote><p>这是本人第一篇关于源码解析的技术博客，由于个人技术的局限性可能也会出现一些错误。所以请大家看到能够帮忙指出，感激不尽。</p></blockquote><h2 id="HashMap变量详解"><a href="#HashMap变量详解" class="headerlink" title="HashMap变量详解"></a>HashMap变量详解</h2><p>HashMap主要有以下几个变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认容器大小，1无符号右移4位，即16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 容器最大值，超过这个值就将threshold设置为Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// HashMap的默认负载因子，关系到HashMap扩容策略</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// HashMap的负载因子，可由构造器传入</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// HashMap扩容阈值，大小为(当前容器大小 * 负载因子)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表转换成红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 红黑树转换成链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 树化时容器的最小值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// HashMap存放K-V的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// HashMap返回所有K-V的Set集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// HashMap的存储元素的大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// HashMap内部修改次数，和迭代器快速失败有关，和源码一起讲</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>以上有些需要补充说明一下:</p><ul><li><p>默认负载因子”DEFAULT_LOAD_FACTOR”为什么是0.75。<br>这个可以参考一个小姐姐的简书，<a href="https://www.jianshu.com/p/64f6de3ffcc1" target="_blank" rel="noopener">HashMap的loadFactor为什么是0.75？</a>笔者还是从评论区那里看到知识点才开始阅读Integer源码的。</p></li><li><p>为什么”MAXIMUM_CAPACITY = 1 &lt;&lt; 30”。<br>我们知道，int在java占4字节32位，为什么不是”1 &lt;&lt; 31”，那是因为在Java中，int的首位代表的是正负。如果右移31位那首位变成1，就是负数的最大值了。而且为了扩容时计算方便，HashMap采用的是与运算计算余数，所以规定扩容为2的幂次方，这个后续会讲。所以我们可以知道”1 &lt;&lt; 30”已经是int类型中2的幂次方中最大的正整数。</p></li><li><p>“MIN_TREEIFY_CAPACITY = 64”是什么意思。<br>MIN_TREEIFY_CAPACITY代表树化时容器的最小值，也就是不管HashMap里的元素个数有没有达到threshold的值，如果链表长度超过8个，在进行树化的时候就会判断这个值，低于64触发resize()方法。举个例子，如果很不幸你前8个都在entry数组的第一个bucket中(HashMap里面的数组的下标位置称为桶，存放Node节点)，这个时候扩容阈值如果是默认的则为:(16*0.75=12)&gt;8，远远没有达到扩容的要求，但是HashMap为了减少树化和解树化的开销，会进行resize操作。这个时候扩容成32了。</p></li><li><p>链表转红黑树为什么是8，红黑树转链表为什么是6。<br>前者可以在HashMap源码开头的”Implementation notes”中找到，主要是如果Key使用的是一个好的hashCode算法，容器中超过8的概率只0.00000006，低于一千万分之一。但是你不能阻止用户使用差的hash算法，所以出于性能考虑转化值为8。至于为什么红黑树转换链表是6，这个目前笔者还不知道，不过网上有个很流行的说法是:</p><blockquote><p>红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，而log(6)=2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</p></blockquote></li></ul><h2 id="HashMap的构造器"><a href="#HashMap的构造器" class="headerlink" title="HashMap的构造器"></a>HashMap的构造器</h2><p>HashMap的构造器涉及的方法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断容量是否为负数，是的话抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="comment">// 判断容量是否大于容量最大值，是的话设置容量为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 判断负载因子是否为非0~1之间的小数，不是的话抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    <span class="comment">// 设置负载因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算HashMap容量值，不是2的幂次方通过此方法找到比其大且最邻近的幂值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取传入Map的容量</span></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断内部容量是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 容量为空计算当前负载因子下该容器应当设置的数组大小。</span></span><br><span class="line">            <span class="comment">// 大于MAXIMUM_CAPACITY设置为MAXIMUM_CAPACITY，否则扩容阈值等于当前容量最近的2次幂。</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ? (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果传入的值大于扩容阈值，进行resize()。为什么要进行这步操作而不是直接put呢？</span></span><br><span class="line">        <span class="comment">// 传入Map大于threshold的范围时一定会触发resize()，如果不事先扩容等put过程扩容，需要移动的元素更多了，所以这一步可以节省性能开销。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将传入的Map一个一个塞进我们当前的HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码基本都有注释，我们也看到了，HashMap并没有在构造器中给table进行初始化，其实是因为HashMap把初始化延时到了put操作之中。要说明的重头戏是计算容量的算法，这个的确相当的厉害，本人其实也讲不太清，大家可以看一下<a href="https://www.cnblogs.com/loading4/p/6239441.html" target="_blank" rel="noopener">Java8 HashMap之tableSizeFor</a>这篇博客，我觉得讲解的很清晰了。</p><p><del>但是这个构造器有个BUG，那就是”this.threshold = tableSizeFor(initialCapacity)”实际上应该为”this.threshold = tableSizeFor(initialCapacity) * loadFactor”，这个在ORACLE官方社区上Doug Lea大佬亲自承认的bug，并且在JDK1.9修复了。当然，这并不影响大佬在我心中的高大形象。还有一点就是putMapEntries()方法中”threshold = tableSizeFor(t)”让我存疑，不应该为”threshold = tableSizeFor(t) * loadFactor”，这个没有在社区上看到大佬说是bug，但我感觉是和上一个犯了同一个错吧。</del></p><p><font color="red">经过我多次的debug和源码查看，此处并不是一个bug。当初我在社区看到的bug是在构造器中有参传入(12)和有参传入(12,0.75)他们的初始容量不一致。具体数值我不太清楚了，但是doug lea大佬说这的确是一个bug，我下意识的以为是我认为的bug了，不过在深入了解之后发现有参构造的threshold是为了在put操作给table初始化容量用的，下一章会讲到。我会努力再找到这个问题，看看具体bug到底是什么。</font></p><p>还有一个有意思的地方是”Float.isNaN(loadFactor)”这个方法。给大家看看方法和示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNaN</span><span class="params">(<span class="keyword">float</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (v != v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Float.isNaN(<span class="number">0.0f</span> / <span class="number">0.0f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看看这个方法，想想输出会是什么呢？是报错还是输出true或者false呢？因为这个不在本文范畴内，所以给大家一个参考链接吧。大家先思考一下再带着疑问去<a href="https://www.cnblogs.com/big-xuyue/p/4106130.html" target="_blank" rel="noopener">有趣的NaN类型</a>寻找答案吧。</p><p>本来打算今晚手撕红黑树，结果发现撕的脑壳疼，没有画图我自己都理不清。然而我还是个手残党不会画图，红黑树暂时不讲吧。今天的第一章暂时讲到这，明天我理一理应该按什么顺序讲好一点吧。</p><h2 id="相关系列"><a href="#相关系列" class="headerlink" title="相关系列"></a>相关系列</h2><p><a href="https://ovvow.com/posts/hashMap-two/#more" target="_blank" rel="noopener">基于JDK1.8的HashMap源码解析二(put和resize操作)</a><br><a href="https://ovvow.com/posts/hashMap-three/#more" target="_blank" rel="noopener">基于JDK1.8的HashMap源码解析三(get和remove以及迭代器)</a></p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap之tableSizeFor</title>
    <url>/posts/hashMap-tableSizeFor/</url>
    <content><![CDATA[<p>无用知识点系列二：HashMap之tableSizeFor方法解析。</p><a id="more"></a><h3 id="tableSizeFor方法"><a href="#tableSizeFor方法" class="headerlink" title="tableSizeFor方法"></a>tableSizeFor方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 hashMap 和 ConcurrentHashMap 中，对于有参构造的时候，用通过 tableSizeFor 方法定位离参数最近的 2 次幂容量。现在我们来解析一下这个方法。</p><h3 id="tableSizeFor方法解析"><a href="#tableSizeFor方法解析" class="headerlink" title="tableSizeFor方法解析"></a>tableSizeFor方法解析</h3><ol><li>n = c - 1；按下不表</li><li>n |= n &gt;&gt;&gt; 1；将 n 右移一位之后再进行或运算。首先我们知道或运算有 1 则为 1。那么这次运算之后，这个数最高位为 1，因为与自身右移 1 位再或运算，则最高位和其下一位也为 1。</li><li>n |= n &gt;&gt;&gt; 2；这次运算原理如上，可以得知能让最前面两个 1 与右移后的自己运算，能保证从最高位算起的前 4 位为 1。</li><li>… 一路套娃到 16 之后，因为 int 最高 32 位，可以保证从最高位为 1 的数之后一定全为 1。</li><li>return n + 1；由上可得，在从 n 最高位为 1 的数之后都是 1，加 1 之后一定是进位后的 2^n。</li></ol><p>举个例子 有个数是 1XXXXXXX（范围为：128~255），在第一次过后这个数为 11XXXXXX，第二次过后则为 1111XXXX， 第三次为11111111。之后几次保持不变。此时 n + 1 则为 100000000 即 2^8 = 256。所以不管 1 后面是什么，运算后一定是在其最高位之前一位的 2 的次方。</p><h3 id="为什么要第一步-n-1"><a href="#为什么要第一步-n-1" class="headerlink" title="为什么要第一步 n-1"></a>为什么要第一步 n-1</h3><p>接下来我们要看看，为什么要在之前做一步 n - 1 的运算，这是因为设计者考虑到参数刚好为 2^n，这时候就不需要再去找 2^(n+1)，而是直接将其作为当前容量，否则我们在传入 128 的时候，因为没有减 1，经过一系列右移或运算之后，得到的结果为 256，这显然与我们的目标不一致了，因此设计者才将其减 1 后运算。保证参数刚好为 2^n 之时不出错。</p><h3 id="作者的话"><a href="#作者的话" class="headerlink" title="作者的话"></a>作者的话</h3><p>今天的风儿甚是喧嚣，可惜已没人听得懂我这句话什么意思。</p>]]></content>
      <categories>
        <category>每天一个没用知识点</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JDK1.8的HashMap源码解析二(put和resize操作)</title>
    <url>/posts/hashMap-two/</url>
    <content><![CDATA[<p>本篇博客主要讲解了HashMap的put和resize操作</p><a id="more"></a><h2 id="相关系列"><a href="#相关系列" class="headerlink" title="相关系列"></a>相关系列</h2><blockquote><p><a href="https://ovvow.com/posts/hashMap-one/#more" target="_blank" rel="noopener">基于JDK1.8的HashMap源码解析一(变量和构造器)</a><br><a href="https://ovvow.com/posts/hashMap-three/#more" target="_blank" rel="noopener">基于JDK1.8的HashMap源码解析三(get和remove以及迭代器)</a></p></blockquote><h2 id="HashMap节点解析"><a href="#HashMap节点解析" class="headerlink" title="HashMap节点解析"></a>HashMap节点解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap普通节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点hash值，为HashMap方法hash(key)得到，和Node节点自身的hashCode()无关</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// HashMap的key值</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// HashMap的value值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 当前节点指向的下一节点(HashMap产生冲突时将会采用尾插法将新增节点插入下一节点)</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;</span><br><span class="line">    <span class="comment">// 是否红节点</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap拥有两种不同的节点，一种是普通的链表节点，一种是红黑树节点。红黑树比较难解析，因为HashMap源码跳过红黑树如何转换我们也能看懂，所以我打算以后放在一章专门的文章中讲解。普通节点很简单，其实就是我们大学数据结构课程常见的链表节点，我相信大家也能看懂，所以也不过多讲解了。</p><h2 id="HashMap的put操作"><a href="#HashMap的put操作" class="headerlink" title="HashMap的put操作"></a>HashMap的put操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算key的hash，这是一个"扰动函数"让高16和低16位进行异或，使分布更平衡，主要是为了防止差的hash函数</span></span><br><span class="line"><span class="comment">// key为null的hash为0，所以key为null的键值对存放在table[0],和普通节点并无区别(HashMap1.7对key为null进行了特殊处理)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *实现map.put和相关方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value  value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent  如果为true，则不更改现有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被替换的值，如果没有，则返回null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab是table的一个局部引用，p作用用来记录节点，同时用于后续循环记录位置</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果集合没有初始化，则进行resize初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 将插入的bucket元素赋值给p，同时判断插入的bucket有没有其他Node，没有直接插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e用来记录是否存在存在插入的key的节点，后期用来判断更新</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果当前bucket头结点等于插入的key，则用e记录当前的节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树，则进行红黑树的操作 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 插入的key不等于头结点，进入此分支判断</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进入循环判断是要新增还是更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果e等于null，则代表遍历到最后依旧没有对应的key，执行新增操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 到了红黑树转换阈值则转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果遍历途中有与插入的key相同的节点，跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">// 记录当前遍历操作的节点</span></span><br><span class="line">                 p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后e存在，则更新值；如果是putIfAbsent()方法，则不更新返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 这是为linkedHashMap留的后路</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 更新则直接跳出函数</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加内部操作的次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 新增之后对size进行自增，如果达到扩容阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap的插入中如果有当前key不更新方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是HashMap的put操作的过程，总结如下:<font color="red">put首先判断是否初始化，没有就进行初始化操作。如果已经进行了初始化操作，根据hash判断插入的bucket中是否有值，没有则直接插入。如果有值，则循环遍历当前链表，找到是否存在相应的key，不存在执行插入操作，否则执行更新操作，期间插入过程到了红黑树的阈值则转换成红黑树。</font></p><h2 id="HashMap的resize操作"><a href="#HashMap的resize操作" class="headerlink" title="HashMap的resize操作"></a>HashMap的resize操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 内部entry数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 内部数组大小</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 内部扩容阈值，可以看下构造器，如果是有参构造此值为新的容器所需要的大小，即2的幂次方</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 扩容后entry数组大小，扩容后扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果entry数组大小不为空并且大于等于最大容量值，则将扩容阈值设为int最大值并返回原entry数组退出</span></span><br><span class="line">        <span class="comment">// 因为此时数组不再支持扩容了(其实设为MAXIMUM_CAPACITY也行)</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果支持扩容，则将旧数组容量和扩容阈值都扩容一倍(因为是2的幂次方)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果entry数组容量等于0且旧的扩容阈值大于0，将初始化容量设为扩容阈值</span></span><br><span class="line">    <span class="comment">//此情况存在于有参构造HashMap中，这下知道扩容阈值为什么不*loadFactor吧，避免无用计算</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果两个都为空(无参构造)，将容量和扩容阈值都设为默认</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的扩容阈值等于0，则设置成容量*负载因子，也判断了边界</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 创建新的entry数组，大小为扩容后大小并赋值给当前entry数组</span></span><br><span class="line">    <span class="comment">// 注意，若此时并发get，会出现取值错误，所以HashMap是线程不安全的</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 循环取出每一个bucket中的Node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 取完就清除旧的引用，用完就扔</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// bucket中的节点没有子节点的话直接赋值给新的bucket</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 此处运算是计算新节点的位置，因为新容量值是旧的两倍，减1与运算之后要么是 原位置 要么是 原位置+oldCap</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 红黑树节点暂不解析，等我自己啃透吧</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 链表非单节点进行链表重组</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 低位头结点，低位尾结点(低位代表原来位置)，另，尾结点不代表末尾节点，可以理解为后一个节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 高位头结点，高位尾结点(高位代表原来位置+oldCap)</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取下一节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 节点hash和旧容量进行与操作，若为0，则代表新位置为原来的位置</span></span><br><span class="line">                        <span class="comment">// 为什么可以这样确定呢，因为oldCap是2的幂次方，和oldCap-1比除了新增位为1，其余都为0，</span></span><br><span class="line">                        <span class="comment">// 因此可以得出节点hash值新增位是0还是1，进而判断是原位置还是原位置+oldCap</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果尾节点为null则将当前节点设置为头结点，否则插入尾结点之后，并将尾结点设置为当前节点</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 原理同上，不过是高位节点的设置</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 判断尾结点的下一节点是否为null,不为null继续进入循环</span></span><br><span class="line">                    <span class="comment">// 这里要绕过一个弯，因为最开始保存了头结点，且最开始的尾结点也是头结点</span></span><br><span class="line">                    <span class="comment">// 第二次的时候loTail.next = e;实际上因为loHead和loTail都是指向最初的头结点</span></span><br><span class="line">                    <span class="comment">// 所以你要知道这相当于给loHead插入了一个尾结点，之后继续用loTail记录插入的尾结点</span></span><br><span class="line">                    <span class="comment">// 所以loTail的作用仅仅是用于保存上一个尾结点并且将新的节点插入再记录当前节点(过了循环就是上一个的尾节点了)</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将最后的尾结点的下一节点设置为null，将新链表的头节点插入bucket</span></span><br><span class="line">                    <span class="comment">// Tail判断为null的理由是可能resize()后仍然全在一个bucket</span></span><br><span class="line">                    <span class="comment">// Tail.next设置为null的理由是低位的尾结点可能还残留高位的尾结点(或相反)</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是HashMap的resize()全过程了，每一步我都进行了详细的说明，现在系统的说一下它的全过程吧。<font color="red">因为HashMap的延时初始化策略，首先判断是否初始化，没有则根据构造方法进行初始化容量，同时也判断了是否超出最大容量的边界。正常扩容阶段则创建一个新的entry数组，同时将原entry数组中的每一个bucket中的元素通过尾插法(JDK1.7中使用得头插法)移动到新的bucket中。另外，hashMap没有对key为null的键值对进行特殊处理</font>整个过程也很简单，只是一些细节方面可能需要理解一下。</p><p>好了，第二章的解析就到这里吧，我们下章再见，因为笔者不会画图，如果有同学画图厉害愿意帮忙把其中一些不好理解的操作画图给我那就太感激不尽啦。</p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Integer之你所不知道的bug</title>
    <url>/posts/integer-bug/</url>
    <content><![CDATA[<p>本篇博客主要讲解了一些integer常见的bug</p><a id="more"></a><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>本来以为自己的博客没几个人看，但是群里的小伙伴却很认真的看完了，顺便还帮我找了几个语病，提了不少建议。这里我要感谢一下<a href="https://github.com/Rukawalee" target="_blank" rel="noopener">@Rukawalee</a>,这位同学是我的审稿小王子，不辞辛劳的帮我审稿，调整语言和篇幅，修改一些语病，以达到最好的阅读体验(内心OS：好歹初中语文年级第一，怎会沦落为现在这样语病百出的地步，哭唧唧)。应小伙伴们的建议，我将这篇文章进行重写，添加了一些Integer的知识点，同时也增加了一些例子，让同学们能更加清晰，更加深入的了解Integer的秘密。当然，这个知识点并不仅仅局限于int和Integer，所有的基础类型和包装类型的知识点都是互通的，这里只是以int和Integer为例而已。</p><h2 id="bug缘起"><a href="#bug缘起" class="headerlink" title="bug缘起"></a>bug缘起</h2><p>今天日常在牛客群里和小伙伴们吹水聊天，我聊到代码规范的时候吐槽了一波，公司每个人的代码规范都不统一，int和integer有的人用equals有的人用==。然后建议统一用equals。于是贴了一波代码为了佐证一下我的建议吧。代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我说，如果写出这样的代码，直接就掉空指针异常坑里了，所以还是最好统一使用equals方法。然而，群里的小伙伴可能是为了捧哏故意说不知道有啥问题。嗯，于是我不要脸的好为人师了一把，既然大家给面子，那就装一波(手动滑稽)。这次，我就从源头上来剖析包装类和基本数据类型的区别以及bug出现的原因。</p><h2 id="int及其包装类"><a href="#int及其包装类" class="headerlink" title="int及其包装类"></a>int及其包装类</h2><h3 id="Integer的起源"><a href="#Integer的起源" class="headerlink" title="Integer的起源"></a>Integer的起源</h3><p><font color="red">在Java中，因为基本类型并不是一个类，它是以值的形式存储在虚拟机内存中。因此它不能在Object之间直接引用。</font>比如说在Map中作为泛型使用或者像Object一样调用方法。如果我们想将基本类型当做类来处理，这个时候我们就需要使用到包装类Integer了。包装类是JDK1.0中提供的，他解决了基本数据类型和Object之间不能直接传递的缺陷。</p><h3 id="int的自动装箱和拆箱"><a href="#int的自动装箱和拆箱" class="headerlink" title="int的自动装箱和拆箱"></a>int的自动装箱和拆箱</h3><p>在JDK1.5之前，int和Integer是不能直接比较的，它需要我们自己显式的调用intValue()进行比较。但是在JDK1.5之后提供了拆箱和装箱的功能之后，我们可以直接将其进行==比较。当然，它同时还提供了其他的便利，待会我会以代码进行一一解释。</p><h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p>我们看下面一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>;</span><br><span class="line">        encasement(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encasement</span><span class="params">(Object i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            System.out.println(<span class="string">"int 被包装成了 Integer"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"int 并没有被包装成Integer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们思考一下，上面的代码会输出什么呢，相信聪明的读者已经知道了答案，那就是:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> 被包装成了 Integer</span><br></pre></td></tr></table></figure><p>接下来，我们来解析上面的一段代码，因为引入了自动装箱机制，<font color="red">“Integer i = 10”实际上是调用了valueOf()方法，所以上面的方法等同于”Integer i = Integer.valueOf(10)”。注意，这个不等同于”Integer i = new Integer(10)”。</font>为什么强调这一点呢，我待会会讲到。</p><p>然后就是第二行代码了，我们前面说过，int不能在Object之间直接引用，为什么我的int能被encasement方法接收呢，原因也是内部做了装箱操作，在方法的传递中，我们的编译器悄悄的把int转换成了Integer，从输出结果也可以看出来了。</p><h4 id="Integer的-到底比较的是什么"><a href="#Integer的-到底比较的是什么" class="headerlink" title="Integer的==到底比较的是什么"></a>Integer的==到底比较的是什么</h4><p>我们大家应该都知道，<font color="red">==除基本类型比较的是值之外，Object类型都是比较地址的。</font>Integer也不例外，但是细心的小伙伴可能会发现下面这个问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">10</span>; <span class="comment">// 实际为 Integer a = Integer.valueOf(10);</span></span><br><span class="line">        Integer b = <span class="number">10</span>;</span><br><span class="line">        Integer c = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line">        Integer e = <span class="number">200</span>;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(b == c);</span><br><span class="line">        System.out.println(d == e);</span><br><span class="line">        System.out.println(d.equals(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><font color="red">同学们注意了，以上均为Integer，实际上比较的是对象的引用(即地址)。</font>但是为什么第一个会输出true呢，按照常理来说，第一个输出结果应该为false呀。同学们别急，听我慢慢给你们解释。解释前我们先看一段源码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    ...<span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        ...<span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在上面已经说到过对Integer直接赋值，编译器会自动优化成对valueOf()方法的调用。所以蹊跷必然出现在这个valueOf()方法。通过源码我们可以发现，<font color="red">Integer内部有一个IntegerCache的内部类，这个内部类里面维护了一个cache[]的Integer数组，数组的大小为256，范围是-128~127。而我们的valueOf()方法是判断int的值是否是在这个区间内。如果在这个区间内，我们返回的则是cache数组中的Integer对象，否则new一个新的Integer对象出来。</font>这下我们应该就明白了为什么第一个会输出true了，因为他们返回的都是同一个对象，当然地址就是一样的啦。<font color="red">第二个输出为false的原因是new关键字的含义就是从内存中申请分配空间，所以地址必然是不一样的</font>。至于第三个为什么false，那是因为超出了区间调用了new Integer()，所以地址也是不一样的。<font color="red">这也是为什么装箱不是调用的new，因为如果调用的是new，那么第一个输出只会是false了。</font>而我们的equals()方法则是通过上一节讲的装箱操作，将int转换为Integer之后通过比较类型再将两个对象的value值进行比较，所以只要值相等就会返回true，参考第四个输出。对了，IntegerCache的区间是可调的，至于具体操作，因为不在这篇博客讲解的范围内，大家可自行google或者百度。</p><h4 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h4><p>还是先看一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        encasement(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encasement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>我们来详解一下，我们之前说过<font color="red">除了基本数据类型，java对象==比较的都是地址，因此基本数据类型是无法和除包装类以外的Object使用==进行比较。同时也不能在Object之间直接引用。</font>那为什么上面代码可以通过编译并且输出true呢，那是因为int包装类型在和int进行比较的时候会隐式的调用intValue()方法，所以在”a == b”这一句代码中，其实真正的语法是”a == b.intValue()”。”encasement(i)”同理，在进行参数传递的时候调用了intValue()方法。因此我们可以使用int来接收它。</p><h2 id="为什么会有bug"><a href="#为什么会有bug" class="headerlink" title="为什么会有bug"></a>为什么会有bug</h2><p>好吧，我们回到之前的问题中来，我相信大家都快忘了问题是什么，没关系，我把代码再贴一下。顺便请问一下同学们，下面的代码会出现什么bug呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">    System.out.println(<span class="keyword">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细思考一下哦，思考完之后看看下面的结果和你猜想的是不是一样的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">	at com.example.test.Test04.main(Test04.java:17)</span><br></pre></td></tr></table></figure><p>为什么会抛出空指针异常呢，我相信聪明的小伙伴们已经知道了原因了，那就是因为”a == b”实际上是”a == b.intValue()”,而我们的b为null，这就导致了空指针异常的发生。虽然我们直接写出来对比很直观，但是在写项目的时候如果直接使用==来比较int和Integer可能就会忘了Integer为null的情况，若是通过测试上线后发现问题，那就是个惨痛的教训了。</p><p>因此，我个人建议使用equals来比较int和Integer，因为在这之前我们必然要考虑到Integer等于null的情况，避免了跳进坑里面。同时，建议大家项目中的POJO类都使用包装类型而不是基本数据类型，因为有的时候需要用null来表示一些异常情况。比如说股市的涨幅情况，如果出了问题导致没有获取到这个数值，使用Integer我们能使用-来表示获取失败，而如果是int，经过序列化之后获取的则是0，那显然是一个错误的值。</p><p>然后，一个小伙伴说，他们项目组刚遇到这个问题，并且还放到公司的wiki上面去了。我相信通过上面的解释，大家应该都能知道为什么需要加三目表达式了吧。<br><img src="https://cloud.ovvow.com/static/images/integer-bug.png" alt></p><h2 id="通过bug我们学习到了什么"><a href="#通过bug我们学习到了什么" class="headerlink" title="通过bug我们学习到了什么"></a>通过bug我们学习到了什么</h2><p>其实，这个bug我们大家都能避免的。因为Integer的装箱和拆箱机制大家应该都是知道的，这个知识点就和基础类型的隐式装换一样烂熟于心了。可是为什么还是会掉进这个陷进里面去呢，我想还是太大意，没有去深入思考。我们都知道Integer和int比较会有拆箱操作，却没有认真的去思考java是如何拆箱的，知其然却不知其所以然，最终导致错误的发生。</p><p>其实Integer这个类是有很多可以学习到的知识点，所以我建议大家可以去看看这个的源码。最后，对于每一个知识点，我们都应该知其然并知其所以然，应该发散自己的思维，通过现象看本质。这样我们才能在工作中完美的避开那些隐蔽的坑。</p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>java虚拟机类加载机制</title>
    <url>/posts/java-classloading/</url>
    <content><![CDATA[<p>本文主要讲解了java类加载机制</p><a id="more"></a><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>我们编写的“.java”类文件最终都会被编译器编译为“.class”的拓展名文件，而“.class”文件中保存着Java代码经转换后的虚拟机指令，当我们需要使用一个类的时候，就需要将这个文件加载进内存中保存为我们所说的class对象。而将.class文件加载到虚拟机内存中的过程称为类加载。类加载过程如下：<br><img src="https://cloud.ovvow.com/static/images/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类加载的过程"></p><ul><li><p>加载：类加载过程的一个阶段，需要经过以下阶段：通过一个类的全限定名来获取定义此类的二进制流，然后将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，之后再内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据访问入口。</p></li><li><p>验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p></li><li><p>准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i = 123;这里只将 i 初始化为 0，至于 123 的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p></li><li><p>解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析。</p></li><li><p>初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。</p></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="启动（Bootstrap）类加载器"><a href="#启动（Bootstrap）类加载器" class="headerlink" title="启动（Bootstrap）类加载器"></a>启动（Bootstrap）类加载器</h3><p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将<java_home>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</java_home></p><h3 id="扩展（Extension）类加载器"><a href="#扩展（Extension）类加载器" class="headerlink" title="扩展（Extension）类加载器"></a>扩展（Extension）类加载器</h3><p>扩展类加载器由sun.misc.Launcher$ExtClassLoader实现，是Launcher的静态内部类，它负责加载<java_home>/lib/ext目录下或者由系统变量java.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</java_home></p><h3 id="应用程序（Application）类加载器"><a href="#应用程序（Application）类加载器" class="headerlink" title="应用程序（Application）类加载器"></a>应用程序（Application）类加载器</h3><p>此加载器是ClassLoader.getSystemClassLoader()方法的返回值，因此又称系统类加载器，是由sun.misc.Launcher$AppClassLoader实现。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，方法可以获取到该类加载器。</p><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器。在加载某个类的class文件时，Java虚拟机采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面我们进一步了解它。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，<font color="red">请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码。</font>类加载器间的关系如下：<br><img src="https://cloud.ovvow.com/static/images/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="双亲委派模型"><br>双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。双亲委派的实现集中在 java.lang.ClassLoader 的 loadClass() 方法中，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">         <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">         Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     c = findBootstrapClassOrNull(name);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                 <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                 <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                 <span class="comment">// to find the class.</span></span><br><span class="line">                 <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                 c = findClass(name);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">             resolveClass(c);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> c;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="双亲委派模型的优势"><a href="#双亲委派模型的优势" class="headerlink" title="双亲委派模型的优势"></a>双亲委派模型的优势</h3><p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。例如类 java.lang.Object 他存放在rt.java中，无论哪一个类加载器加载这个类，最终都会委派给最顶层的启动类加载器进行加载。我们想象一下，如果没有双亲委派，那么用户自己编写了一个 java.lang.Object 类，并存放在ClassPath中，那系统将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序将变得一片混乱。</p><h3 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="headerlink" title="如何破坏双亲委派模型"></a>如何破坏双亲委派模型</h3><p>既然我们知道，双亲委派模型是通过loadClass方法实现，那么我们只要自定义类加载器继承ClassLoader并覆写起loadClass方法。具体代码示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String rootDic = <span class="string">"D:\\IdeaProjects\\test\\src\\main\\java\\"</span>;</span><br><span class="line">                    String fileName = rootDic + name.replace(<span class="string">"."</span>, File.separator) + <span class="string">".class"</span>;</span><br><span class="line">                    FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">4</span>];</span><br><span class="line">                    <span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((n = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] byteArray = baos.toByteArray();</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj = classLoader.loadClass(<span class="string">"com.ovvow.test.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下，我们改写了ClassLoader的loadClass方法，直接使用 defineClass() 强行加载 ClassLoaderTest，结果输出如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">ovvow</span>.<span class="title">mybatis</span>.<span class="title">utils</span>.<span class="title">ClassLoaderTest</span></span></span><br><span class="line"><span class="class"><span class="title">false</span></span></span><br></pre></td></tr></table></figure><p>我们发现第二个输出为 false，说明判断两个类是否是同一个类，除了加载的类文件一样，还必须由同一个类加载器加载。这时候有人会想到，<font color="red">如果我在自己文件中创建一个 java.lang.String 文件，那是否可以通过自定义类加载器加载进我们的虚拟机中呢？答案是：不行。</font>如果你通过百度去查的话，或许你能看到有些同学说可以。但这其实是因为有些人想当然的结果，他们并没有去验证结果，同时也没有阅读过源码，就导致一个错误的知识点慢慢就扩散开了。所以学知识，百度只是参考，需要自己去验证。</p><p>我们来看看 defineClass() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, </span><br><span class="line">                                     ProtectionDomain protectionDomain) <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ProtectionDomain <span class="title">preDefineClass</span><span class="params">(String name, ProtectionDomain pd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(<span class="string">"IllegalName: "</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class="line">    <span class="comment">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class="line">    <span class="comment">// of the form "java.*"</span></span><br><span class="line">    <span class="keyword">if</span> ((name != <span class="keyword">null</span>) &amp;&amp; name.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException</span><br><span class="line">            (<span class="string">"Prohibited package name: "</span> +</span><br><span class="line">             name.substring(<span class="number">0</span>, name.lastIndexOf(<span class="string">'.'</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pd = defaultDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所有的类加载最终都会走到这个方法去加载类文件， 我们看到它是个final方法，是无法被我们重写的，其中调用了 preDefineClass() 方法进行了前置验证，而前置验证中直接就把 “java”开头的所有类文件给拒绝加载了，直接抛出 SecurityException 异常，因此不管你这个类是通过何种途径加载的，只要你是 java 开头，就会直接抛出一个异常。<font color="red">(ps：在《深入理解java虚拟机》第 255 页最底下的注解也说明了，加载java.lang.String是会抛异常的)</font></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实还有很多没有讲完，还有很多可以拓展的，比如说各种加载器parent的隐藏关系，JDBC是如何破坏的双亲委派实现驱动加载等等。但是目前水平就到这了，后续学习理解完再补充。</p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java引用类型</title>
    <url>/posts/java-reference/</url>
    <content><![CDATA[<p>本篇博客主要讲解了java的四种引用类型</p><a id="more"></a><h3 id="1-前言——垃圾回收如何判断对象已“死”？"><a href="#1-前言——垃圾回收如何判断对象已“死”？" class="headerlink" title="1. 前言——垃圾回收如何判断对象已“死”？"></a>1. 前言——垃圾回收如何判断对象已“死”？</h3><p>在堆中基本存放了java中所有的对象实例，垃圾收集器在对堆进行回收的时候，首先要确认的就是哪些对象还“存活”着，哪些对象已经“死去”(即不再被任何途径使用)。而在判断对象存活的方法中，主要有两种。</p><ol><li><strong>引用计数法：</strong> 引用计数法主要是给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1，当引用失效的时候，计数减1；当计数器为0的时候，说明这个对象便不会再被使用。</li><li><strong>可达性分析：</strong> 这个算法的思路就是通过一系列的称为“GC Roots”作为对象的起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），每当一个对象到 GC Roots 没有任何引用链相连，则证明此对象不可用。</li></ol><p>在引用计数法这种方式中，如果两个对象没有其他的对象对其进行引用，但是这两个对象有相互引用的情况。则引用计数永远不会为0，导致不会被回收，即使他们已经不会再被使用了。具体示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">        Test test2 = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        test1.instance = test2;</span><br><span class="line">        test2.instance = test1;</span><br><span class="line"></span><br><span class="line">        test1 = <span class="keyword">null</span>;</span><br><span class="line">        test2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在示例中，即使test1和test2互相引用，但是方法执行完之后这两个对象已经不会再使用了，因此虽然引用计数不为 0，但也应该被GC所清理，在实际试验中也的确如此。说明java虚拟机采用的是 GC Roots的方式来清理对象。</p><p>在java语言中，可作为GC Roots的对象有以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。（即 static 变量）</li><li>方法区中常量引用的对象。（即 static final 变量）</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><h3 id="2-什么是四大引用类型？"><a href="#2-什么是四大引用类型？" class="headerlink" title="2. 什么是四大引用类型？"></a>2. 什么是四大引用类型？</h3><p>为了能够描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还非常紧张，则可以抛弃这些对象。在JDK1.2之后，java对引用进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4中，这四种引用强度依次逐渐减弱。</p><ol><li><strong>强引用：</strong> 强引用就是指在程序代码之中普遍存在的，如通过 new 关键字创建、反射、clone、序列化等方式创建的对象，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><strong>软引用：</strong> 软引用是用来描述一些还有用但并非必须的对象，对于软引用关联的对象，一般状态下是不会被垃圾收集器回收，只有在系统将要发生内存溢出异常之前，才会将该引用的对象列入垃圾回收目标进行回收。在JDK1.2 之后，提供了 SoftReference 类来实现软引用。</li><li><strong>弱引用：</strong> 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在JDK1.2 之后，提供了 WeakReference 类来实现弱引用。</li><li><strong>虚引用：</strong> 　虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。为一个对象设置虚引用关联的唯一目的就是在这个对象被回收时收到一个系统通知。在JDK1.2 之后，提供了 PhantomReference类表示 类来实现虚引用。</li></ol><p>强引用我们应该不用去过多详解，大家在开发中随处可见的就是强引用的运用。而软引用的使用场景之一便是作为缓存存在，将一些可能被频繁查询的数据保存在内存中，在内存紧张的时候也能被回收不至于出现 OOM。虚引用的话可以用来监控一些重要对象的GC回收状态，做一些日志记录（<font color="red">其实我也不知道它有哪些有用的使用场景</font>）。至于弱引用，JAVA中我们常见的ThreadLocal就使用了它，他能用于保障一些频繁使用但生命周期短的对象处于一个线程隔离的状态，通过每个线程自带的ThreadLocalMap来存储这些对象，以此解决对象不能被多线程共享的问题。</p><h3 id="3-引用是否能持有多种？"><a href="#3-引用是否能持有多种？" class="headerlink" title="3. 引用是否能持有多种？"></a>3. 引用是否能持有多种？</h3><p>开始讲解之前，我们看一下下面的一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WeakReference&lt;Date&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="comment">// Date date = weakReference.get();</span></span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(weakReference.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行这段代码的时候，输出结果是 null，原理大家想必都知道，当我们调用 System.gc() 时，因为弱引用的关系，我们的Date()对象被回收，因此弱引用中所持有的对象被清理导致为null。而当我们把代码中的注释放开，我们会发现输出的结果不是 null，而是 “Fri Jun 12 18:27:33 CST 2020”。想必大家就开始很迷惑了，Date()不是个弱引用吗，为什么没有被垃圾回收，为什么还能输出？</p><p>答案就是：<font color="red">一个对象可以持有多种引用，在垃圾回收的时候，以其最强的引用对待此对象。</font>在注释存在的时候，只有一条弱引用 weakReference —&gt; new Date() 存在。因此，在GC的时候，new Date() 遵循弱引用的回收机制将其回收。而在注释放开的时候，则存在两条引用链，一条为强引用链 date —&gt; new Date()，一条弱引用链 weakReference —&gt; new Date()。在拥有多条引用的时候，GC回收则是按强引用回收对待 new Date()，因此new Date()并不会被回收。引用关系如图：</p><p><img src="https://cloud.ovvow.com/static/images/date%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB.png" alt="new Date()的引用关系"></p><h3 id="4-ThreadLocal内存泄漏的原因"><a href="#4-ThreadLocal内存泄漏的原因" class="headerlink" title="4. ThreadLocal内存泄漏的原因"></a>4. ThreadLocal内存泄漏的原因</h3><p>首先我们大致了解一下ThreadLocal的原理。每个 Thread（线程）为了保证数据隔离，其内部存储了一个 ThreadLocal 的内部类 ThreadLocalMap，在使用的时候我们可以创建一个ThreadLocal，通过其 set() 方法，将对象保存在ThreadLocalMap中，其中 key 为创建的 ThreadLocal，value 为我们 set 的对象。</p><p>我们来看一个示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocal&lt;Date&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> Date());</span><br><span class="line">    threadLocal = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码的使用中，会产生以下几条引用链：</p><p><img src="https://cloud.ovvow.com/static/images/ThreadLocal%E5%BC%95%E7%94%A8%E9%93%BE.png" alt="ThreadLocal的引用链"><br>上图中，实线代表强引用，虚线代表的是弱引用。我们发现ThreadLocal对象实际持有两个引用，一个我们代码第一行中显式 new 出来的 threadLocal 强引用，另一个则是通过 set() 方法在 Entry 中作为一个虚引用的 key。同时，也会有一条当前线程到 entry 的强引用，即 currentThread（当前线程）-&gt; threadLocalMap -&gt; entry。如果我们将外部强引用置为 null，那么 ThreadLocal 对象只有一条虚引用，在 GC 的时候势必会被回收，则此时的 key 为null。而此时仍然存在当前线程到 value 的一条强引用，虽然此时 map 的 key 为 null，该 value 永远不会被访问到，但强引用的存在导致其不能被回收，只有线程被销毁的时候，这条强引用才会断开。然而我们实际应用中都会使用线程池去维护线程，就导致其无法被回收，造成内存泄漏。</p><p>当然，实际上 ThreadLocal 在 set 和 get 的过程中也会去清除一些临近的过期的 value。但是这也不能完全避免内存泄漏的情况，因此我们在使用完对象的时候，最好调用 remove 方法清除 value。</p><h3 id="5-夹带私货"><a href="#5-夹带私货" class="headerlink" title="5. 夹带私货"></a>5. 夹带私货</h3><p>周杰伦出新歌了，歌名是《Mojito》，大家看完别忘了支持一波。虽说不及巅峰之作，但是异域的风格也是周董的一次突破了，中间的 RAP 部分也十分抓耳，保证听了不亏好伐。</p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式的六种写法</title>
    <url>/posts/singleton/</url>
    <content><![CDATA[<p>本篇博客主要说明了一下单例模式的六种写法</p><a id="more"></a><h2 id="谈谈单例模式"><a href="#谈谈单例模式" class="headerlink" title="谈谈单例模式"></a>谈谈单例模式</h2><p>单例模式，顾名思义就是创建一个唯一的实例。因为有些场景，我们只需要也只能创建一个实例，举个例子：windows是我们所熟悉的系统，我们会发现，当你打开控制面板的时候，无论你打开多少次，都只会有一个控制面板出现，这也是单例模式的一种应用。在java中，我们应用比较广泛的单例模式就有线程池和缓存。</p><h2 id="单例模式的六种写法"><a href="#单例模式的六种写法" class="headerlink" title="单例模式的六种写法"></a>单例模式的六种写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest HUNGER_INSTANCE = <span class="keyword">new</span> SingletonTest();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonTest <span class="title">getHungerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGER_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉模式，用名字来说就是：应用程序很饥饿，急切的需要这个对象来“喂饱”自己。饿汉模式特点是在类加载的时候就初始化了示例对象，它的优点是高效、安全，但缺点就是，如果这是一个使用场景很少，但耗内存的对象，会造成内存的浪费(这种情况就是应用并不“饥饿”，只有在想“吃”的时候才要它)。<br><font color="red">当然，这是大家公认的解释，但是稍微了解点设计模式的都知道单一职责原则，也就是一个类只负责一种功能，一般情况下，我们需要使用的单例都只依赖于他的getInstance(),也就是说，我们需要加载单例类的时候就是我们需要这个类的实例的时候，也就不存在内存消耗的问题了。在大多数应用场景里面，我们使用饿汉模式就已经能够满足我们的工作需求了。除非这个类比较特殊，还对外提供了一些static的方法，这种情况饿汉模式就不适用了</font></p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest LAZY_INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonTest <span class="title">getLazyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LAZY_INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LAZY_INSTANCE = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LAZY_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉模式，用名字来说就是：我很懒，只有需要我的时候再来实例化我。懒汉模式的特点就是能够实现懒加载(lazy loading),即只在需要的时候才创建实例。但是他的缺点也十分明显，因为要实现多线程下的安全性，所以在方法中加锁导致了性能大大降低了，因为除了第一次初始化需要锁保证安全，其他的时候并不需要加锁。所以我们一般是不会使用懒汉模式的。但是，懒汉模式给我们传递了一种思路，就是懒加载的思路，这个在我们项目的使用和设计的时候，都应该需要有的一个思路。</p><h3 id="双重检查锁模式-double-check"><a href="#双重检查锁模式-double-check" class="headerlink" title="双重检查锁模式(double-check)"></a>双重检查锁模式(double-check)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonTest DOUBLE_CHECK_INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getDoubleCheckInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DOUBLE_CHECK_INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (DOUBLE_CHECK_INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    DOUBLE_CHECK_INSTANCE = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DOUBLE_CHECK_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁是懒汉模式的一种升级版，前面我们说过，单例模式需要保证的就是在初始化实例时候的线程安全问题。所以双重检查锁优化了懒汉模式，将锁的粒度细化，只在创建单例的时候进行加锁。这样，不仅保障了多线程下的安全问题，也保证了效率。<br>双重检查锁的确是一个比较优秀的单例应用模式，但是双重检查锁也是问题最多的一种模式。<font color="red">因为JVM虚拟机在为了优化执行的速度，在保障happen-before的原则下会产生指令重排序的情况，这样就会出现部分初始化的问题，导致在调用方法的时候抛出初始化异常，解决的方案就是在变量前面加上volatile变量。</font>但实际上，volatile的语义在不同的虚拟机上也不一样，在一些古老的虚拟机上，volatile也并不能完全禁止指定重排序，当然，可能现在也没人用，了解一下即可。(PS:笔者并不推荐使用这种写法，因为有比它更好更便捷的方法)</p><h3 id="枚举-天然的单例对象"><a href="#枚举-天然的单例对象" class="headerlink" title="枚举(天然的单例对象)"></a>枚举(天然的单例对象)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用SingletonTestEnum.INSTANCE获取单例对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> SingletonTestEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    SingletonTestEnum() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举其实没什么好说的，枚举是java的一个语法糖，实际上是一个继承了enum的final类。但是枚举是一个天然的单例模式，用法也非常简单，安全性也是最高的，因为其他方法虽然保证了应用程序方面的安全性，但是面对暴力反射构造创建对象还是没有办法的。当然，也可以通过构造器里抛异常来解决暴力反射，具体可以看看StandardCharsets这个类，他就是通过在构造器里抛异常来阻止暴力反射的。枚举的缺点也很明显的，因为他没法实现懒加载。</p><h3 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest INSTANCE = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类就是我所见过的最好的一种单例模式的方法。只要构建一个静态内部类，并在内部类中构造单例对象。这样既保证了多线程情况下的安全性，同时也实现了懒加载。笔者极力推荐大家使用这种方法。</p><h3 id="CAS法"><a href="#CAS法" class="headerlink" title="CAS法"></a>CAS法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;SingletonTest&gt; CAS_INSTANCE = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getCasInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            SingletonTest singleton = CAS_INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (singleton != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">            <span class="keyword">if</span> (CAS_INSTANCE.compareAndSet(<span class="keyword">null</span>, singleton)) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS没什么可说的，实际上就是利用CAS的原子性来保障只有一个对象被成功构建。这种写法也实现了懒加载。当然，这是我在学习的时候看到CAS的原子性想到能不能用CAS来构造单例模式呢，于是自己试了一下写出来，然后google一下发现还真有这种写法。但是其实这种写法的缺陷也是很明显的，那就是虽然能保证能拿到对象是单例的，但并不能保证只实例化一个对象，如果这是一个比较“笨重”的对象，这样就会加重虚拟机内存的负担。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实，单例模式应该算是设计模式中比较简单的一个模式，但是其中包含的知识点其实并不少，比如说懒加载涉及到了类加载机制，双重检查锁那部分则涉及到了JVM的happen-before和指令重排序的知识点。虽然单例模式无脑使用静态内部类也没什么问题，但是我们学习的目的不是为了怎么方便的写一个单例模式，而是从中学习到设计的思路，为什么有饿汉模式、懒汉模式和双重检查锁等众多的单例模式。这些模式的出现就是前人在系统优化过程中不断研究中创造的，我们真正需要学习的是发散性的思维和他们的创新能力。</p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java虚拟机内存详解</title>
    <url>/posts/java-virtual-machine-one/</url>
    <content><![CDATA[<p>本篇博客主要讲解了java虚拟机的内存区域</p><a id="more"></a><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>在正篇开始前，我们先来看看两张图：<br><img src="https://cloud.ovvow.com/static/images/c%2B%2B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.gif" alt="C++垃圾收集机制"><br><img src="https://cloud.ovvow.com/static/images/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.gif" alt="java垃圾收集机制"><br>相信以上两张图大家都看过吧，对于C/C++程序员来说，每一个对象在创建的时候都需要自己手动去写 delete/free 操作来释放内存(如图一，是不是很形象)，虽然这样可以保证每一个对象都被正确的释放内存，避免内存溢出和内存泄漏的问题。但是，这是一个相当耗费精气神的事情，有时自己因为疏忽未释放对象导致产生问题。java 则和C/C++不同，程序员把内存控制权利交给 Java 虚拟机，然而，虚拟机不是万能的，如果我们不了解虚拟机内存状态，一旦出现内存泄漏和溢出方面的问题，那么排查错误是非常困难的(如图二，工具不是万能的)。</p><h3 id="2-java虚拟机运行时数据库"><a href="#2-java虚拟机运行时数据库" class="headerlink" title="2. java虚拟机运行时数据库"></a>2. java虚拟机运行时数据库</h3><p>java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，以下是根据《java虚拟机规范(SE 7版)》的规定下，java内存区域的划分。<br><img src="https://cloud.ovvow.com/static/images/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="JVM内存模型"></p><h4 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h4><p>程序计数器(Program Counter Register)是一块极小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值开选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。</p><p>因为现在一个处理器（多核处理器来说是一个内核）只会执行一条程序指令，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p><font color="red">注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域。</font></p><h4 id="2-2-java虚拟机栈"><a href="#2-2-java虚拟机栈" class="headerlink" title="2.2 java虚拟机栈"></a>2.2 java虚拟机栈</h4><p>java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同，虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的时候会创建一个<b>栈帧</b>来存储局部变量表、操作数栈、动态链接、方法出入口等信息，每一个方法的执行到结束，实际都是一个栈帧在虚拟机栈中入栈到出栈的过程。</p><ol><li><p>局部变量表：局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它并不等同于对象，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。</p></li><li><p>操作数栈：操作数栈(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。有关操作数栈的详细指令可参考：<a href="https://emacsist.github.io/2017/06/19/jvm%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">jvm字节码学习与理解</a></p></li><li><p>动态连接：在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。 这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。</p></li><li><p>方法返回：在方法正常完成退出或者异常完成退出后都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。当方法正常完成退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。</p></li></ol><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><ul><li>StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展(大部分虚拟机都可动态拓展，只是Java虚拟机规范中允许固定长度的虚拟机栈)，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li>OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p><font color="red">注意：在32位虚拟机上，long和double占用了2个word，因此对于long和double的操作是非原子性的，在64位虚拟机上，long和double的操作是原子性的，为了程序的可移植性，最好在涉及原子操作时使用volatile保障其原子性</font></p><h4 id="2-3-java堆"><a href="#2-3-java堆" class="headerlink" title="2.3 java堆"></a>2.3 java堆</h4><p>Java堆（Heap）是虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：在细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>Java堆在没有内存完成实例分配，并且堆也无法再拓展的时候，会抛出OutOfMemoryError。</p><h4 id="2-4-方法区"><a href="#2-4-方法区" class="headerlink" title="2.4 方法区"></a>2.4 方法区</h4><p>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出(OutOfMemoryError)问题。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。</p><p><font color="red">注意：我们要区分开JMM（java内存模型）和JVM虚拟机的区别，JMM定义了是 JVM 的规范，而后者则是 JVM 规范的一种实现，在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</font></p><h4 id="2-5-运行时常量池"><a href="#2-5-运行时常量池" class="headerlink" title="2.5 运行时常量池"></a>2.5 运行时常量池</h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）。既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><font color="red">注意：为了方便JDK1.8中永久代向元空间转变，在JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</font></p><h4 id="2-6-直接内存"><a href="#2-6-直接内存" class="headerlink" title="2.6 直接内存"></a>2.6 直接内存</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</p><p>JDK1.4中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。虽然本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h3 id="3-有关字符串的补充"><a href="#3-有关字符串的补充" class="headerlink" title="3. 有关字符串的补充"></a>3. 有关字符串的补充</h3><h4 id="3-1-String对象的创建："><a href="#3-1-String对象的创建：" class="headerlink" title="3.1 String对象的创建："></a>3.1 String对象的创建：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">"abc"</span>;</span><br><span class="line">    String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在图上例子中，a = “abc” 会首先在常量池中查找是否存在该字符串，如果存在则a直接指向常量池中的 “abc”；如果不存在，则在常量池中创建 “abc” ,之后将a指向该字符串。 b = new String(“abc”) 则是通过 new 关键字，直接在堆内分配内存创建 “abc”，之后再将 b 指向该字符串。另外，只要是通过 new 创建的对象，都是直接在堆内分配内存。因此，a == b 的结果是false，因为一个指向的是常量池中的字符串，一个指向的是堆中的字符串。</p><h4 id="3-2-String-intern"><a href="#3-2-String-intern" class="headerlink" title="3.2 String.intern()"></a>3.2 String.intern()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在JDK1.6中，会得到两个false，而在JDK1.7中，会得到一个true和一个false。产生差异的原因是：在JDK1.6中，intern() 方法会把首次遇到的字符串实例复制到永久代中(即永久代中的字符串常量池中)，返回的也是永久代中这个字符串实例的引用。而StringBuilder创建的字符串实例在java堆上，所以必然不是一个引用，因此都返回false。</p><p>而在JDK1.7中的 intern() 不会再复制实例，只是在常量池中记录首次出现的实例医用，因此 intern() 返回的引用和由StringBuilder创建的那个字符串是同一个实例。对str2比较返回false的原因是因为“java”这个字符串在执行StringBuilder.toString()就出现过了(注：java在虚拟机启动的时候内部初始化并使用过)，所以字符串常量池中已经有了它的引用，不符合“首次出现”的原则。而“计算机软件”这个字符串则是首次出现，因此返回true。</p><h4 id="3-2-有关字符串相加编译器的优化"><a href="#3-2-有关字符串相加编译器的优化" class="headerlink" title="3.2 有关字符串相加编译器的优化"></a>3.2 有关字符串相加编译器的优化</h4><p><font color="red">前景提要：本代码的编译环境为JDK1.8，用到了上一节 String.intern() 的知识点</font></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sbBc = <span class="keyword">new</span> StringBuilder(<span class="string">"b"</span>).append(<span class="string">"c"</span>).toString();</span><br><span class="line">    String str1 = <span class="string">"a"</span> + <span class="string">"bc"</span>;</span><br><span class="line">    String str2 = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="comment">// System.out.println(sbBc.intern() == sbBc); // true</span></span><br><span class="line">    String str3 = str1 + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">    System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str2 == str3); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// System.out.println(sbBc.intern() == sbBc); // false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在进行编译的时候会有一些优化操作，例如从”str1 == str2” 的输出是true的情况中我们可以看出，编译器在两个常量直接相加的时候，会直接将常量编译成一个整体，即将 “a” + “bc” 直接编译成 “abc”。 因此，str1 == str2 输出为 true。为了验证我们可以把第四行被注释的输出语句放开，我们会发现他的结果是true，这说明在str1的赋值中，是没有生成 “bc” 这个常量的，而是直接编译成了 “abc”。</p><p>而在有变量的情况下，编译器无法识别变量 a, 但是编译器依然会将其优化成 StringBuild.append() 进行相加之后调用 toString() 方法。并且，编译器还能智能的识别到”b” + “c”这个可以直接编译成 “bc”，因此在 append() 调用的时候，编译器会直接优化成 append(“bc”) 而不是append(“b”).append(“c”) ,验证的时候，我们只需要注释掉第一个打印输出，放开最后一个打印输出，你会发现最终输出的结果是false，这能够证明 “bc” 常量是在优化成 append(“bc”) 的时候生成在常量池中的。</p><p>当然，我还会从java编译后的字节码中进一步验证这个知识点，上述代码生成的字节码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: ldc           #3                  // String b</span><br><span class="line">       6: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">       9: ldc           #5                  // String c</span><br><span class="line">      11: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      14: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">17</span>: astore_1</span><br><span class="line">      18: ldc           #8                  // String abc</span><br><span class="line">      <span class="number">20</span>: astore_2</span><br><span class="line">      21: ldc           #8                  // String abc</span><br><span class="line">      <span class="number">23</span>: astore_3</span><br><span class="line">      24: new           #2                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">27</span>: dup</span><br><span class="line">      28: invokespecial #9                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      <span class="number">31</span>: aload_2</span><br><span class="line">      32: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      35: ldc           #10                 // String bc</span><br><span class="line">      37: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      40: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">43</span>: astore        <span class="number">4</span></span><br><span class="line">      45: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">48</span>: aload_1</span><br><span class="line">      49: invokevirtual #12                 // Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="line">      <span class="number">52</span>: aload_1</span><br><span class="line">      <span class="number">53</span>: if_acmpne     <span class="number">60</span></span><br><span class="line">      <span class="number">56</span>: iconst_1</span><br><span class="line">      <span class="number">57</span>: goto          <span class="number">61</span></span><br><span class="line">      <span class="number">60</span>: iconst_0</span><br><span class="line">      61: invokevirtual #13                 // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">      64: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">67</span>: aload_2</span><br><span class="line">      <span class="number">68</span>: aload_3</span><br><span class="line">      <span class="number">69</span>: if_acmpne     <span class="number">76</span></span><br><span class="line">      <span class="number">72</span>: iconst_1</span><br><span class="line">      <span class="number">73</span>: goto          <span class="number">77</span></span><br><span class="line">      <span class="number">76</span>: iconst_0</span><br><span class="line">      77: invokevirtual #13                 // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">      80: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">83</span>: aload_3</span><br><span class="line">      <span class="number">84</span>: aload         <span class="number">4</span></span><br><span class="line">      <span class="number">86</span>: if_acmpne     <span class="number">93</span></span><br><span class="line">      <span class="number">89</span>: iconst_1</span><br><span class="line">      <span class="number">90</span>: goto          <span class="number">94</span></span><br><span class="line">      <span class="number">93</span>: iconst_0</span><br><span class="line">      94: invokevirtual #13                 // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">      <span class="number">97</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码我就不解释了，大家有兴趣可以看参考这个网站：<a href="https://emacsist.github.io/2017/06/19/jvm%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">jvm字节码学习与理解</a>。字节码对应的java代码解释如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">6</span>：String sbBc = <span class="keyword">new</span> StringBuilder(<span class="string">"b"</span>)</span><br><span class="line"><span class="number">9</span>-<span class="number">11</span>：sbBc.append(<span class="string">"c"</span>)</span><br><span class="line"><span class="number">14</span>: sbBc.toString() <span class="comment">// 至此，整体对应为：String sbBc = new StringBuilder("b").append("c").toString()。</span></span><br><span class="line"><span class="number">17</span>-<span class="number">18</span> String str1 = <span class="string">"abc"</span></span><br><span class="line"><span class="number">20</span>-<span class="number">21</span> String str2 = <span class="string">"abc"</span></span><br><span class="line"><span class="number">23</span>-<span class="number">28</span> String str3 = <span class="keyword">new</span> StringBuilder() </span><br><span class="line"><span class="number">31</span>-<span class="number">32</span> str3.append(a)</span><br><span class="line"><span class="number">35</span> 将bc入栈放入常量池</span><br><span class="line"><span class="number">37</span> str3.append(<span class="string">"bc"</span>)</span><br><span class="line"><span class="number">40</span> str3.toString()</span><br></pre></td></tr></table></figure><p>在 17-18 和 20-21 中我们可以发现str1和str2生成的字节码完全一样，证明了编译器的第一点优化。而 23-40 所对应的字节码我们可以发现，编译器加字符串相加优化成了StringBuilder的 append() 调用，同时编译器还将将后面的 “b” + “c” 优化成了 “bc”。</p><h3 id="4-来点哲学？"><a href="#4-来点哲学？" class="headerlink" title="4 来点哲学？"></a>4 来点哲学？</h3><p>最近空间看到一条说说：“有的人没有得到什么，却希望别人能够得到；有的人没有得到什么，却希望别人也得不到。”看完之后，还是有点感触的。我向来都是支持人性本恶的观点，一切的“善”不过是一种道德思维以及修养的学习与提升。因为恶往往是与生俱来对自我的放纵，所以我们要学做人，学处事之道。而此道并无终点，有些人总是徘徊在原点嘲笑别人无止境的前行，企图将别人和自己捆绑在“地狱”之中。这和学生时期不肯学习的人嘲笑别人学习竟如出一辙，或许是同一批人长大了吧。</p>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu服务器前置配置笔记</title>
    <url>/posts/ubuntu-config/</url>
    <content><![CDATA[<p>Ubuntu服务器设置的脚本，主要以后自己折腾的时候少费点劲</p><a id="more"></a><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载vim-plug</span></span><br><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决vim乱码</span></span><br><span class="line">echo 'set fileencodings=utf-8,gbk,utf-16le,cp1252,iso-8859-15,ucs-bom</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf-8' &gt;&gt;/etc/vim/vimrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑.vimrc</span></span><br><span class="line">echo 'set nocompatible</span><br><span class="line">call plug#begin('~/.vim/plugged')</span><br><span class="line">Plug 'kien/ctrlp.vim'</span><br><span class="line">Plug 'vim-airline/vim-airline'</span><br><span class="line">Plug 'morhetz/gruvbox'</span><br><span class="line">call plug#end()</span><br><span class="line">set nu</span><br><span class="line">syntax on</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set tabstop=4</span><br><span class="line">set expandtab' &gt;&gt;~/.vimrcs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 跑完上去手动:PlugStatus和:PlugInstall</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载zsh</span></span><br><span class="line">sudo apt -y install zsh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载oh-my-zsh</span></span><br><span class="line">sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑.zshrc</span></span><br><span class="line">echo '#开启纠错提醒</span><br><span class="line">setopt correctall</span><br><span class="line"><span class="meta">#</span><span class="bash">开启高级命令提示符功能</span></span><br><span class="line">autoload -U promptinit</span><br><span class="line">promptinit</span><br><span class="line"><span class="meta">#</span><span class="bash">开启颜色</span></span><br><span class="line">autoload -U colors &amp;&amp; colors</span><br><span class="line"><span class="meta">#</span><span class="bash">设置忽略重复记录</span></span><br><span class="line">setopt hist_ignore_all_dups</span><br><span class="line"><span class="meta">#</span><span class="bash">配置提示符模式</span></span><br><span class="line">prompt redhat</span><br><span class="line"><span class="meta">#</span><span class="bash">在行末显示上一命令的返回状态</span></span><br><span class="line">RPROMPT="[%&#123;$fg_bold[yellow]%&#125;%?%&#123;$reset_color%&#125;]"</span><br><span class="line">[ -f ~/.fzf.zsh ] &amp;&amp; source ~/.fzf.zsh' &gt;&gt;~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新配置文件</span></span><br><span class="line">source ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置默认zsh启动</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker</span></span><br><span class="line">sudo apt -y install docker.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并设置开机自启</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将docker作为非root启动</span></span><br><span class="line">if [[ -n $1 ]]</span><br><span class="line">    usermod -aG docker $1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>脚本的vim-plug和zsh任意用户可用，docker要root用户启动，输入一个参数为常用登录用户名可以启动docker，主要是烦输密码。</p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql安装</span></span><br><span class="line">sudo apt-get install mysql-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql初始化</span></span><br><span class="line">sudo mysql_secure_installation</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改mysql监听端口，注释掉<span class="built_in">bind</span>，以便能监听远程访问</span></span><br><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  进入服务</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置远程可访问并更新</span></span><br><span class="line">grant all on *.* to root@'%' identified by '你的密码' with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启mysql</span></span><br><span class="line">systemctl restart mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql初始化的时候会要你设置密码强度0是最低，2是最高，看情况设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果后期想用纯数字密码修改密码强度使用如下语句，请不要忘了commit</span></span><br><span class="line">set global validate_password_policy=0;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>我比较喜欢systemctl管理服务，它是Linux自带的命令，也可以兼容service。</p><h2 id="腾讯云服务器设置允许root登录"><a href="#腾讯云服务器设置允许root登录" class="headerlink" title="腾讯云服务器设置允许root登录"></a>腾讯云服务器设置允许root登录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置root密码先</span></span><br><span class="line">sudo passwd root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改ssh配置，将PermitRootLogin改为yes</span></span><br><span class="line">sudo vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启ssh服务</span></span><br><span class="line">sudo systemctl restart ssh # 或者sudo service ssh restart</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一千行 MySQL 学习笔记</title>
    <url>/posts/mysql-note/</url>
    <content><![CDATA[<p>本文主要是记录了一下mysql学习笔记</p><a id="more"></a><p>本文转载自：<a href="https://shockerli.net/post/1000-line-mysql-note/" target="_blank" rel="noopener">https://shockerli.net/post/1000-line-mysql-note/</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Windows服务 */</span></span><br><span class="line"><span class="comment">-- 启动MySQL</span></span><br><span class="line">    net <span class="keyword">start</span> mysql</span><br><span class="line"><span class="comment">-- 创建Windows服务</span></span><br><span class="line">    sc <span class="keyword">create</span> mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连接与断开服务器 */</span></span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span> <span class="comment">-- 显示哪些线程正在运行</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="comment">-- 显示系统变量信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据库操作 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- 查看当前数据库</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br><span class="line"><span class="comment">-- 显示当前时间、用户名、数据库版本</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">now</span>(), <span class="keyword">user</span>(), <span class="keyword">version</span>();</span><br><span class="line"><span class="comment">-- 创建库</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>[ <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name</span><br><span class="line">        <span class="keyword">COLLATE</span> collation_name</span><br><span class="line"><span class="comment">-- 查看已有库</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>[ <span class="keyword">LIKE</span> <span class="string">'PATTERN'</span>]</span><br><span class="line"><span class="comment">-- 查看当前库信息</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名</span><br><span class="line"><span class="comment">-- 修改库的选项信息</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> 库名 选项信息</span><br><span class="line"><span class="comment">-- 删除库</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">DATABASE</span>[ <span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表的操作 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line">    <span class="keyword">CREATE</span> [<span class="keyword">TEMPORARY</span>] <span class="keyword">TABLE</span>[ <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">    每个字段必须有数据类型</span><br><span class="line">    最后一个字段后不能有逗号</span><br><span class="line">    <span class="keyword">TEMPORARY</span> 临时表，会话结束时表自动消失</span><br><span class="line">    对于字段的定义：</span><br><span class="line">    字段名 数据类型 [<span class="keyword">NOT</span> <span class="literal">NULL</span> | <span class="literal">NULL</span>] [<span class="keyword">DEFAULT</span> default_value] [AUTO_INCREMENT] [<span class="keyword">UNIQUE</span> [<span class="keyword">KEY</span>] | [PRIMARY] <span class="keyword">KEY</span>] [<span class="keyword">COMMENT</span> <span class="string">'string'</span>]</span><br><span class="line"><span class="comment">-- 表选项</span></span><br><span class="line">    <span class="comment">-- 字符集</span></span><br><span class="line">        <span class="keyword">CHARSET</span> = charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    <span class="comment">-- 存储引擎</span></span><br><span class="line">        <span class="keyword">ENGINE</span> = engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：<span class="keyword">InnoDB</span> MyISAM <span class="keyword">Memory</span>/<span class="keyword">Heap</span> BDB <span class="keyword">Merge</span> Example CSV MaxDB <span class="keyword">Archive</span></span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        <span class="keyword">InnoDB</span>表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        <span class="keyword">SHOW</span> <span class="keyword">ENGINES</span> <span class="comment">-- 显示存储引擎的状态信息</span></span><br><span class="line">        <span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> 引擎名 &#123;<span class="keyword">LOGS</span>|<span class="keyword">STATUS</span>&#125; <span class="comment">-- 显示存储引擎的日志或状态信息</span></span><br><span class="line">    <span class="comment">-- 自增起始数</span></span><br><span class="line">    	AUTO_INCREMENT = 行数</span><br><span class="line">    <span class="comment">-- 数据文件目录</span></span><br><span class="line">        <span class="keyword">DATA</span> <span class="keyword">DIRECTORY</span> = <span class="string">'目录'</span></span><br><span class="line">    <span class="comment">-- 索引文件目录</span></span><br><span class="line">        <span class="keyword">INDEX</span> <span class="keyword">DIRECTORY</span> = <span class="string">'目录'</span></span><br><span class="line">    <span class="comment">-- 表注释</span></span><br><span class="line">        <span class="keyword">COMMENT</span> = <span class="string">'string'</span></span><br><span class="line">    <span class="comment">-- 分区选项</span></span><br><span class="line">        <span class="keyword">PARTITION</span> <span class="keyword">BY</span> ... (详细见手册)</span><br><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLES</span>[ <span class="keyword">LIKE</span> <span class="string">'pattern'</span>]</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLES</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 查看表机构</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 （信息更详细）</span><br><span class="line">    <span class="keyword">DESC</span> 表名 / <span class="keyword">DESCRIBE</span> 表名 / <span class="keyword">EXPLAIN</span> 表名 / <span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">LIKE</span> <span class="string">'PATTERN'</span>]</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> [<span class="keyword">FROM</span> db_name] [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]</span><br><span class="line"><span class="comment">-- 修改表</span></span><br><span class="line">    <span class="comment">-- 修改表本身的选项</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 表的选项</span><br><span class="line">        eg: <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ENGINE</span>=MYISAM;</span><br><span class="line">    <span class="comment">-- 对表进行重命名</span></span><br><span class="line">        <span class="keyword">RENAME</span> <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 新表名</span><br><span class="line">        <span class="keyword">RENAME</span> <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        <span class="comment">-- RENAME可以交换两个表名</span></span><br><span class="line">    <span class="comment">-- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 操作名</span><br><span class="line">        <span class="comment">-- 操作名</span></span><br><span class="line">            <span class="keyword">ADD</span>[ <span class="keyword">COLUMN</span>] 字段定义       <span class="comment">-- 增加字段</span></span><br><span class="line">                <span class="keyword">AFTER</span> 字段名          <span class="comment">-- 表示增加在该字段名后面</span></span><br><span class="line">                <span class="keyword">FIRST</span>               <span class="comment">-- 表示增加在第一个</span></span><br><span class="line">            <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(字段名)   <span class="comment">-- 创建主键</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [索引名] (字段名)<span class="comment">-- 创建唯一索引</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">INDEX</span> [索引名] (字段名) <span class="comment">-- 创建普通索引</span></span><br><span class="line">            <span class="keyword">DROP</span>[ <span class="keyword">COLUMN</span>] 字段名      <span class="comment">-- 删除字段</span></span><br><span class="line">            <span class="keyword">MODIFY</span>[ <span class="keyword">COLUMN</span>] 字段名 字段属性     <span class="comment">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span></span><br><span class="line">            <span class="keyword">CHANGE</span>[ <span class="keyword">COLUMN</span>] 原字段名 新字段名 字段属性      <span class="comment">-- 支持对字段名修改</span></span><br><span class="line">            <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>    <span class="comment">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名 <span class="comment">-- 删除索引</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键    <span class="comment">-- 删除外键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">TABLE</span>[ <span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 表名 ...</span><br><span class="line"><span class="comment">-- 清空表数据</span></span><br><span class="line">    <span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] 表名</span><br><span class="line"><span class="comment">-- 复制表结构</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">LIKE</span> 要复制的表名</span><br><span class="line"><span class="comment">-- 复制表结构和数据</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 [<span class="keyword">AS</span>] <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 要复制的表名</span><br><span class="line"><span class="comment">-- 检查表是否有错误</span></span><br><span class="line">    <span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [<span class="keyword">option</span>] ...</span><br><span class="line"><span class="comment">-- 优化表</span></span><br><span class="line">    <span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br><span class="line"><span class="comment">-- 修复表</span></span><br><span class="line">    <span class="keyword">REPAIR</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [<span class="keyword">QUICK</span>] [<span class="keyword">EXTENDED</span>] [USE_FRM]</span><br><span class="line"><span class="comment">-- 分析表</span></span><br><span class="line">    <span class="keyword">ANALYZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据操作 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- 增</span></span><br><span class="line">    <span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 [(字段列表)] <span class="keyword">VALUES</span> (值列表)[, (值列表), ...]</span><br><span class="line">        <span class="comment">-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span></span><br><span class="line">        <span class="comment">-- 可同时插入多条数据记录！</span></span><br><span class="line">        <span class="keyword">REPLACE</span> 与 <span class="keyword">INSERT</span> 完全一样，可互换。</span><br><span class="line">    <span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 <span class="keyword">SET</span> 字段名=值[, 字段名=值, ...]</span><br><span class="line"><span class="comment">-- 查</span></span><br><span class="line">    <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名[ 其他子句]</span><br><span class="line">        <span class="comment">-- 可来自多个表的多个字段</span></span><br><span class="line">        <span class="comment">-- 其他子句可以不使用</span></span><br><span class="line">        <span class="comment">-- 字段列表可以用*代替，表示所有字段</span></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line"><span class="comment">-- 改</span></span><br><span class="line">    <span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名=新值[, 字段名=新值] [更新条件]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符集编码 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- MySQL、数据库、表、字段均可设置编码</span></span><br><span class="line"><span class="comment">-- 数据编码与客户端编码不需一致</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'character_set_%'</span>   <span class="comment">-- 查看所有字符集编码项</span></span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line"><span class="keyword">SET</span> 变量名 = 变量值</span><br><span class="line">    <span class="keyword">SET</span> character_set_client = gbk;</span><br><span class="line">    <span class="keyword">SET</span> character_set_results = gbk;</span><br><span class="line">    <span class="keyword">SET</span> character_set_connection = gbk;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> GBK;  <span class="comment">-- 相当于完成以上三个设置</span></span><br><span class="line"><span class="comment">-- 校对集</span></span><br><span class="line">    校对集用以排序</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]/<span class="keyword">SHOW</span> <span class="keyword">CHARSET</span> [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]   查看所有字符集</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]     查看所有校对集</span><br><span class="line">    <span class="keyword">CHARSET</span> 字符集编码     设置字符集编码</span><br><span class="line">    <span class="keyword">COLLATE</span> 校对集编码     设置校对集编码</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据类型（列类型） */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="number">1.</span> 数值类型</span><br><span class="line"><span class="comment">-- a. 整型 ----------</span></span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    <span class="built_in">tinyint</span>     <span class="number">1</span>字节    <span class="number">-128</span> ~ <span class="number">127</span>      无符号位：<span class="number">0</span> ~ <span class="number">255</span></span><br><span class="line">    <span class="built_in">smallint</span>    <span class="number">2</span>字节    <span class="number">-32768</span> ~ <span class="number">32767</span></span><br><span class="line">    mediumint   <span class="number">3</span>字节    <span class="number">-8388608</span> ~ <span class="number">8388607</span></span><br><span class="line">    <span class="built_in">int</span>         <span class="number">4</span>字节</span><br><span class="line">    <span class="built_in">bigint</span>      <span class="number">8</span>字节</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，<span class="keyword">unsigned</span> 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以<span class="number">0</span>补填，zerofill 属性修改</span><br><span class="line">        例：<span class="built_in">int</span>(<span class="number">5</span>)   插入一个数<span class="string">'123'</span>，补填后为<span class="string">'00123'</span></span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - <span class="number">1</span>表示<span class="built_in">bool</span>值真，<span class="number">0</span>表示<span class="built_in">bool</span>值假。MySQL没有布尔类型，通过整型<span class="number">0</span>和<span class="number">1</span>表示。常用<span class="built_in">tinyint</span>(<span class="number">1</span>)表示布尔型。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 浮点型 ----------</span></span><br><span class="line">    类型             字节     范围</span><br><span class="line">    <span class="built_in">float</span>(单精度)     <span class="number">4</span>字节</span><br><span class="line">    <span class="keyword">double</span>(双精度)    <span class="number">8</span>字节</span><br><span class="line">    浮点型既支持符号位 <span class="keyword">unsigned</span> 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填<span class="number">0.</span></span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        <span class="built_in">float</span>(M, D)     <span class="keyword">double</span>(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- c. 定点数 ----------</span></span><br><span class="line">    <span class="built_in">decimal</span> <span class="comment">-- 可变长度</span></span><br><span class="line">    <span class="built_in">decimal</span>(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每<span class="number">9</span>位数字保存为<span class="number">4</span>个字节。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 字符串类型</span><br><span class="line"><span class="comment">-- a. char, varchar ----------</span></span><br><span class="line">    <span class="built_in">char</span>    定长字符串，速度快，但浪费空间</span><br><span class="line">    <span class="built_in">varchar</span> 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    <span class="built_in">char</span>,最多<span class="number">255</span>个字符，与编码无关。</span><br><span class="line">    <span class="built_in">varchar</span>,最多<span class="number">65535</span>字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过<span class="number">65535</span>个字节。</span><br><span class="line">        utf8 最大为<span class="number">21844</span>个字符，gbk 最大为<span class="number">32766</span>个字符，latin1 最大为<span class="number">65532</span>个字符</span><br><span class="line">    <span class="built_in">varchar</span> 是变长的，需要利用存储空间保存 <span class="built_in">varchar</span> 的长度，如果数据小于<span class="number">255</span>个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    <span class="built_in">varchar</span> 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是<span class="number">65532</span>字节，因为在<span class="built_in">varchar</span>存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，</span><br><span class="line">    所以有效长度是<span class="number">64432</span><span class="number">-1</span><span class="number">-2</span>=<span class="number">65532</span>字节。例：若一个表定义为 <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb(c1 <span class="built_in">int</span>, c2 <span class="built_in">char</span>(<span class="number">30</span>), c3 <span class="built_in">varchar</span>(N)) <span class="keyword">charset</span>=utf8; </span><br><span class="line">    问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. blob, text ----------</span></span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line"></span><br><span class="line"><span class="comment">-- c. binary, varbinary ----------</span></span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br><span class="line"></span><br><span class="line">3. 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line"></span><br><span class="line">4. 枚举和集合</span><br><span class="line"><span class="comment">-- 枚举(enum) ----------</span></span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 集合（set） ----------</span></span><br><span class="line"><span class="keyword">set</span>(val1, val2, val3...)</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> tab ( gender <span class="keyword">set</span>(<span class="string">'男'</span>, <span class="string">'女'</span>, <span class="string">'无'</span>) );</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="string">'男, 女'</span>);</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，<span class="keyword">SET</span>成员值的尾部空格将自动被删除。</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择类型 */</span></span><br><span class="line"><span class="comment">-- PHP角度</span></span><br><span class="line"><span class="number">1.</span> 功能满足</span><br><span class="line"><span class="number">2.</span> 存储空间尽量小，处理效率更高</span><br><span class="line"><span class="number">3.</span> 考虑兼容问题</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IP存储 ----------</span></span><br><span class="line"><span class="number">1.</span> 只需存储，可用字符串</span><br><span class="line"><span class="number">2.</span> 如果需计算，查找等，可存储为<span class="number">4</span>个字节的无符号<span class="built_in">int</span>，即<span class="keyword">unsigned</span></span><br><span class="line">    <span class="number">1</span>) PHP函数转换</span><br><span class="line">        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。</span><br><span class="line">        利用sprintf函数格式化字符串</span><br><span class="line">        sprintf(<span class="string">"%u"</span>, ip2long(<span class="string">'192.168.3.134'</span>));</span><br><span class="line">        然后用long2ip将整型转回IP字符串</span><br><span class="line">    2) MySQL函数转换(无符号整型，UNSIGNED)</span><br><span class="line">        INET_ATON('127.0.0.1') 将IP转为整型</span><br><span class="line">        INET_NTOA(2130706433) 将整型转为IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 列属性（列约束） */</span> <span class="comment">------------------</span></span><br><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：<span class="keyword">create</span> <span class="keyword">table</span> tab ( <span class="keyword">id</span> <span class="built_in">int</span>, stu <span class="built_in">varchar</span>(<span class="number">10</span>), primary <span class="keyword">key</span> (<span class="keyword">id</span>));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：<span class="keyword">create</span> <span class="keyword">table</span> tab ( <span class="keyword">id</span> <span class="built_in">int</span>, stu <span class="built_in">varchar</span>(<span class="number">10</span>), age <span class="built_in">int</span>, primary <span class="keyword">key</span> (stu, age));</span><br><span class="line"></span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line"></span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'val'</span>);</span><br><span class="line">        <span class="comment">-- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span></span><br><span class="line"></span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="keyword">default</span>, <span class="string">'val'</span>);    <span class="comment">-- 此时表示强制使用默认值。</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> tab ( add_time <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> );</span><br><span class="line">        <span class="comment">-- 表示将当前时间的时间戳设为默认值。</span></span><br><span class="line">        current_date, current_time</span><br><span class="line"></span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 <span class="keyword">alter</span> <span class="keyword">table</span> tbl auto_increment = x;</span><br><span class="line"></span><br><span class="line">6. <span class="keyword">COMMENT</span> 注释</span><br><span class="line">    例：<span class="keyword">create</span> <span class="keyword">table</span> tab ( <span class="keyword">id</span> <span class="built_in">int</span> ) <span class="keyword">comment</span> <span class="string">'注释内容'</span>;</span><br><span class="line"></span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="string">`t1_t2_fk`</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (t1_id) <span class="keyword">references</span> t2(<span class="keyword">id</span>);</span><br><span class="line">        <span class="comment">-- 将表t1的t1_id外键关联到表t2的id字段。</span></span><br><span class="line">        <span class="comment">-- 每个外键都有一个名字，可以通过 constraint 指定</span></span><br><span class="line"></span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line"></span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line"></span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line"></span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on <span class="keyword">update</span> 或 <span class="keyword">on</span> <span class="keyword">delete</span>：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">cascade</span>，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">set</span> <span class="literal">null</span>，设置为<span class="literal">null</span>。主表数据被更新（主键值更新），从表的外键被设置为<span class="literal">null</span>。主表记录被删除，从表相关记录外键被设置成<span class="literal">null</span>。</span><br><span class="line">       但注意，要求该外键列，没有<span class="keyword">not</span> <span class="literal">null</span>属性约束。</span><br><span class="line">    <span class="number">3.</span> restrict，拒绝父表删除和更新。</span><br><span class="line"></span><br><span class="line">    注意，外键只被<span class="keyword">InnoDB</span>存储引擎所支持。其他引擎是不支持的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建表规范 */</span> <span class="comment">------------------</span></span><br><span class="line">    <span class="comment">-- Normal Format, NF</span></span><br><span class="line">        - 每个表保存一个实体信息</span><br><span class="line">        - 每个具有一个<span class="keyword">ID</span>字段作为主键</span><br><span class="line">        - <span class="keyword">ID</span>主键 + 原子表</span><br><span class="line">    <span class="comment">-- 1NF, 第一范式</span></span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    <span class="comment">-- 2NF, 第二范式</span></span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除符合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    <span class="comment">-- 3NF, 第三范式</span></span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SELECT */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] select_expr <span class="keyword">FROM</span> -&gt; <span class="keyword">WHERE</span> -&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> [合计函数] -&gt; <span class="keyword">HAVING</span> -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> -&gt; <span class="keyword">LIMIT</span></span><br><span class="line"></span><br><span class="line">a. select_expr</span><br><span class="line">    <span class="comment">-- 可以用 * 表示所有字段。</span></span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> tb;</span><br><span class="line">    <span class="comment">-- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span></span><br><span class="line">        <span class="keyword">select</span> stu, <span class="number">29</span>+<span class="number">25</span>, <span class="keyword">now</span>() <span class="keyword">from</span> tb;</span><br><span class="line">    <span class="comment">-- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span></span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        <span class="keyword">select</span> stu+<span class="number">10</span> <span class="keyword">as</span> add10 <span class="keyword">from</span> tb;</span><br><span class="line"></span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    <span class="comment">-- 可以为表起别名。使用as关键字。</span></span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">AS</span> tt, tb2 <span class="keyword">AS</span> bb;</span><br><span class="line">    <span class="comment">-- from子句后，可以同时出现多个表。</span></span><br><span class="line">        <span class="comment">-- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span></span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1, tb2;</span><br><span class="line">    <span class="comment">-- 向优化符提示如何选择索引</span></span><br><span class="line">        <span class="keyword">USE</span> <span class="keyword">INDEX</span>、<span class="keyword">IGNORE</span> <span class="keyword">INDEX</span>、<span class="keyword">FORCE</span> <span class="keyword">INDEX</span></span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (key1,key2) <span class="keyword">WHERE</span> key1=<span class="number">1</span> <span class="keyword">AND</span> key2=<span class="number">2</span> <span class="keyword">AND</span> key3=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (key3) <span class="keyword">WHERE</span> key1=<span class="number">1</span> <span class="keyword">AND</span> key2=<span class="number">2</span> <span class="keyword">AND</span> key3=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">c. WHERE 子句</span><br><span class="line">    <span class="comment">-- 从from获得的数据源中进行筛选。</span></span><br><span class="line">    <span class="comment">-- 整型1表示真，0表示假。</span></span><br><span class="line">    <span class="comment">-- 表达式由运算符和运算数组成。</span></span><br><span class="line">        <span class="comment">-- 运算数：变量（字段）、值、函数返回值</span></span><br><span class="line">        <span class="comment">-- 运算符：</span></span><br><span class="line">            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is/is not 加上ture/false/unknown，检验某个值的真假</span><br><span class="line">            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较</span><br><span class="line"></span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段/别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line"></span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line"></span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line"></span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line"></span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line"></span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* UNION */</span> <span class="comment">------------------</span></span><br><span class="line">    将多个<span class="keyword">select</span>查询的结果组合成一个结果集合。</span><br><span class="line">    <span class="keyword">SELECT</span> ... <span class="keyword">UNION</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...</span><br><span class="line">    默认 <span class="keyword">DISTINCT</span> 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个<span class="keyword">SELECT</span>查询加上小括号包裹。</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序时，需加上 <span class="keyword">LIMIT</span> 进行结合。</span><br><span class="line">    需要各<span class="keyword">select</span>查询的字段数量一样。</span><br><span class="line">    每个<span class="keyword">select</span>查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条<span class="keyword">select</span>语句为准。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子查询 */</span> <span class="comment">------------------</span></span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line"><span class="comment">-- from型</span></span><br><span class="line">    <span class="keyword">from</span>后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - <span class="keyword">from</span>型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">0</span>) <span class="keyword">as</span> subfrom <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- where型</span></span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> money = (<span class="keyword">select</span> <span class="keyword">max</span>(money) <span class="keyword">from</span> tb);</span><br><span class="line">    <span class="comment">-- 列子查询</span></span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            <span class="keyword">select</span> column1 <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> t2);</span><br><span class="line">    <span class="comment">-- 行子查询</span></span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> (<span class="keyword">id</span>, gender) <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span>, gender <span class="keyword">from</span> t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 特殊运算符</span></span><br><span class="line">    != all()    相当于 not in</span><br><span class="line">    = some()    相当于 in。any 是 some 的别名</span><br><span class="line">    != some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连接查询(join) */</span> <span class="comment">------------------</span></span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line"><span class="comment">-- 内连接(inner join)</span></span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 交叉连接 cross join</span></span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">cross</span> <span class="keyword">join</span> tb2;</span><br><span class="line"><span class="comment">-- 外连接(outer join)</span></span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    <span class="comment">-- 左外连接 left join</span></span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    <span class="comment">-- 右外连接 right join</span></span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line"><span class="comment">-- 自然连接(natural join)</span></span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex <span class="keyword">from</span> info, extra_info </span><br><span class="line"><span class="keyword">where</span> info.stu_num = extra_info.stu_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导入导出 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> <span class="keyword">outfile</span> 文件地址 [控制格式] <span class="keyword">from</span> 表名;   <span class="comment">-- 导出表数据</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> [<span class="keyword">local</span>] <span class="keyword">infile</span> 文件地址 [<span class="keyword">replace</span>|<span class="keyword">ignore</span>] <span class="keyword">into</span> <span class="keyword">table</span> 表名 [控制格式]; <span class="comment">-- 导入数据</span></span><br><span class="line">    生成的数据默认的分隔符是制表符</span><br><span class="line">    local未指定，则数据文件必须在服务器上</span><br><span class="line">    <span class="keyword">replace</span> 和 <span class="keyword">ignore</span> 关键词控制对现有的唯一键记录的重复的处理</span><br><span class="line"><span class="comment">-- 控制格式</span></span><br><span class="line"><span class="keyword">fields</span>  控制字段格式</span><br><span class="line">默认：<span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">''</span> <span class="keyword">escaped</span> <span class="keyword">by</span> <span class="string">'\\'</span></span><br><span class="line">    <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'string'</span>  <span class="comment">-- 终止</span></span><br><span class="line">    <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">'char'</span>      <span class="comment">-- 包裹</span></span><br><span class="line">    <span class="keyword">escaped</span> <span class="keyword">by</span> <span class="string">'char'</span>       <span class="comment">-- 转义</span></span><br><span class="line">    <span class="comment">-- 示例：</span></span><br><span class="line">        <span class="keyword">SELECT</span> a,b,a+b <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'/tmp/result.text'</span></span><br><span class="line">        <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> <span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span></span><br><span class="line">        <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">FROM</span> test_table;</span><br><span class="line">lines   控制行格式</span><br><span class="line">默认：lines terminated by '\n'</span><br><span class="line">    terminated by 'string'  <span class="comment">-- 终止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* INSERT */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">select</span>语句获得的数据可以用<span class="keyword">insert</span>插入。</span><br><span class="line"></span><br><span class="line">可以省略对列的指定，要求 <span class="keyword">values</span> () 括号内，提供给了按照列顺序出现的所有字段的值。</span><br><span class="line">    或者使用<span class="keyword">set</span>语法。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">SET</span> <span class="keyword">field</span>=<span class="keyword">value</span>,...；</span><br><span class="line"></span><br><span class="line">可以一次性使用多个值，采用(), (), ();的形式。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span> (), (), ();</span><br><span class="line"></span><br><span class="line">可以在列值指定时，使用表达式。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span> (field_value, <span class="number">10</span>+<span class="number">10</span>, <span class="keyword">now</span>());</span><br><span class="line">可以使用一个特殊值 DEFAULT，表示该列使用默认值。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span> (field_value, <span class="keyword">DEFAULT</span>);</span><br><span class="line"></span><br><span class="line">可以通过一个查询的结果，作为需要插入的值。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">SELECT</span> ...;</span><br><span class="line"></span><br><span class="line">可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span>/<span class="keyword">SET</span>/<span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> 字段=值, …;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DELETE */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tbl_name [<span class="keyword">WHERE</span> where_definition] [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...] [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br><span class="line"></span><br><span class="line">按照条件删除。<span class="keyword">where</span></span><br><span class="line"></span><br><span class="line">指定删除的最多记录数。<span class="keyword">limit</span></span><br><span class="line"></span><br><span class="line">可以通过排序条件删除。<span class="keyword">order</span> <span class="keyword">by</span> + <span class="keyword">limit</span></span><br><span class="line"></span><br><span class="line">支持多表删除，使用类似连接语法。</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 需要删除数据多表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">using</span> 表连接操作 条件。</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TRUNCATE */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line"><span class="number">1</span>，<span class="keyword">truncate</span> 是删除表再创建，<span class="keyword">delete</span> 是逐条删除</span><br><span class="line"><span class="number">2</span>，<span class="keyword">truncate</span> 重置auto_increment的值。而<span class="keyword">delete</span>不会</span><br><span class="line"><span class="number">3</span>，<span class="keyword">truncate</span> 不知道删除了几条，而<span class="keyword">delete</span>知道。</span><br><span class="line"><span class="number">4</span>，当被用于带分区的表时，<span class="keyword">truncate</span> 会保留分区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 备份与还原 */</span> <span class="comment">------------------</span></span><br><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出</span></span><br><span class="line">mysqldump [options] db_name [<span class="keyword">tables</span>]</span><br><span class="line">mysqldump [options] <span class="comment">---database DB1 [DB2 DB3...]</span></span><br><span class="line">mysqldump [options] <span class="comment">--all--database</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 导出一张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</span><br><span class="line"><span class="number">2.</span> 导出多张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表<span class="number">1</span> 表<span class="number">2</span> 表<span class="number">3</span> &gt; 文件名(D:/a.sql)</span><br><span class="line"><span class="number">3.</span> 导出所有表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line"><span class="number">4.</span> 导出一个库</span><br><span class="line">　　mysqldump -u用户名 -p密码 <span class="comment">--lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)</span></span><br><span class="line"></span><br><span class="line">可以-w携带<span class="keyword">WHERE</span>条件</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入</span></span><br><span class="line"><span class="number">1.</span> 在登录mysql的情况下：</span><br><span class="line">　　<span class="keyword">source</span>  备份文件</span><br><span class="line"><span class="number">2.</span> 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 视图 */</span> <span class="comment">------------------</span></span><br><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。</span><br><span class="line">    行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。</span><br><span class="line">    通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的<span class="keyword">sql</span>语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，</span><br><span class="line">    如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE&#125;] <span class="keyword">VIEW</span> view_name [(column_list)] <span class="keyword">AS</span> select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用<span class="keyword">select</span>语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于<span class="keyword">SELECT</span>语句检索的列数</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看结构</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">VIEW</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] view_name ...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改视图结构</span></span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name [(column_list)] <span class="keyword">AS</span> select_statement</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 视图作用</span></span><br><span class="line">    <span class="number">1.</span> 简化业务逻辑</span><br><span class="line">    <span class="number">2.</span> 对客户端隐藏真实的表结构</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 视图算法(ALGORITHM)</span></span><br><span class="line">    <span class="keyword">MERGE</span>       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务(transaction) */</span> <span class="comment">------------------</span></span><br><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续<span class="keyword">SQL</span>的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据晚自习方面的一个功能。</span><br><span class="line">    - 需要利用 <span class="keyword">InnoDB</span> 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - <span class="keyword">InnoDB</span>被称为事务安全型引擎。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务开启</span></span><br><span class="line">    <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>; 或者 <span class="keyword">BEGIN</span>;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line"><span class="comment">-- 事务提交</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 事务回滚</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务的特性</span></span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务的实现</span></span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务的原理</span></span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要<span class="keyword">commit</span>提交持久化数据操作。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">    <span class="number">1.</span> 数据定义语言（<span class="keyword">DDL</span>）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    <span class="number">2.</span> 事务不能被嵌套</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line">    <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 设置一个事务保存点</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 回滚到保存点</span></span><br><span class="line">    <span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 删除保存点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- InnoDB自动提交特性设置</span></span><br><span class="line">    <span class="keyword">SET</span> autocommit = <span class="number">0</span>|<span class="number">1</span>;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要<span class="keyword">commit</span>提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>不同的是，</span><br><span class="line">        <span class="keyword">SET</span> autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 锁表 */</span></span><br><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，<span class="keyword">InnoDB</span> 支持行锁</span><br><span class="line"><span class="comment">-- 锁定</span></span><br><span class="line">    <span class="keyword">LOCK</span> <span class="keyword">TABLES</span> tbl_name [<span class="keyword">AS</span> <span class="keyword">alias</span>]</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">    <span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 触发器 */</span> <span class="comment">------------------</span></span><br><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event <span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 <span class="keyword">before</span> 或 <span class="keyword">after</span>，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        <span class="keyword">INSERT</span>：将新行插入表时激活触发程序</span><br><span class="line">        <span class="keyword">UPDATE</span>：更改某一行时激活触发程序</span><br><span class="line">        <span class="keyword">DELETE</span>：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与<span class="keyword">TEMPORARY</span>表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name</span><br><span class="line"></span><br><span class="line">可以使用<span class="keyword">old</span>和<span class="keyword">new</span>代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是<span class="keyword">old</span>，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">    <span class="number">1.</span> 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符连接函数</span></span><br><span class="line"><span class="keyword">concat</span>(str1,str2,...])</span><br><span class="line"><span class="keyword">concat_ws</span>(separator,str1,str2,...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分支语句</span></span><br><span class="line"><span class="keyword">if</span> 条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改最外层语句结束符</span></span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line"></span><br><span class="line">delimiter ;     <span class="comment">-- 修改回原来的分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语句块包裹</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    语句块</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 特殊的执行</span></span><br><span class="line"><span class="number">1.</span> 只要添加记录，就会触发程序。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">Insert</span> <span class="keyword">into</span> <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 <span class="keyword">before</span> <span class="keyword">insert</span>, <span class="keyword">after</span> <span class="keyword">insert</span>;</span><br><span class="line">    如果有重复记录并更新，会触发 before <span class="keyword">insert</span>, <span class="keyword">before</span> <span class="keyword">update</span>, <span class="keyword">after</span> <span class="keyword">update</span>;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before <span class="keyword">insert</span>, <span class="keyword">before</span> <span class="keyword">update</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">Replace</span> 语法 如果有记录，则执行 <span class="keyword">before</span> <span class="keyword">insert</span>, <span class="keyword">before</span> <span class="keyword">delete</span>, <span class="keyword">after</span> <span class="keyword">delete</span>, <span class="keyword">after</span> <span class="keyword">insert</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SQL编程 */</span> <span class="comment">------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 局部变量 ----------</span></span><br><span class="line"><span class="comment">-- 变量声明</span></span><br><span class="line">    <span class="keyword">declare</span> var_name[,...] <span class="keyword">type</span> [<span class="keyword">default</span> <span class="keyword">value</span>]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个<span class="keyword">default</span>子句。值可以被指定为一个表达式，不需要为一个常数。</span><br><span class="line">    如果没有<span class="keyword">default</span>子句，初始值为<span class="literal">null</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋值</span></span><br><span class="line">    使用 <span class="keyword">set</span> 和 <span class="keyword">select</span> <span class="keyword">into</span> 语句为变量赋值。</span><br><span class="line"></span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 全局变量 ----------</span></span><br><span class="line"><span class="comment">-- 定义、赋值</span></span><br><span class="line"><span class="keyword">set</span> 语句可以定义并为变量赋值。</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">var</span> = <span class="keyword">value</span>;</span><br><span class="line">也可以使用<span class="keyword">select</span> <span class="keyword">into</span>语句为变量初始化并赋值。这样要求<span class="keyword">select</span>语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，</span><br><span class="line">变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过<span class="keyword">select</span>执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。</span><br><span class="line">（<span class="keyword">set</span>语句可以使用= 和 :=）。</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">var</span>:=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> @v1:=<span class="keyword">id</span>, @v2=<span class="keyword">name</span> <span class="keyword">from</span> t1 <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_name <span class="keyword">where</span> @<span class="keyword">var</span>:=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">into</span> 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| <span class="keyword">select</span> <span class="keyword">max</span>(height) <span class="keyword">into</span> @max_height <span class="keyword">from</span> tb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自定义变量名</span></span><br><span class="line">为了避免<span class="keyword">select</span>语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@<span class="keyword">var</span>=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 控制结构 ----------</span></span><br><span class="line"><span class="comment">-- if语句</span></span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case语句</span></span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- while循环</span></span><br><span class="line">[begin_label:] <span class="keyword">while</span> search_condition <span class="keyword">do</span></span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span> [end_label];</span><br><span class="line"></span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 退出循环</span></span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 内置函数 ----------</span></span><br><span class="line"><span class="comment">-- 数值函数</span></span><br><span class="line">abs(x)          <span class="comment">-- 绝对值 abs(-10.9) = 10</span></span><br><span class="line">format(x, d)    <span class="comment">-- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span></span><br><span class="line">ceil(x)         <span class="comment">-- 向上取整 ceil(10.1) = 11</span></span><br><span class="line">floor(x)        <span class="comment">-- 向下取整 floor (10.1) = 10</span></span><br><span class="line">round(x)        <span class="comment">-- 四舍五入去整</span></span><br><span class="line">mod(m, n)       <span class="comment">-- m%n m mod n 求余 10%3=1</span></span><br><span class="line">pi()            <span class="comment">-- 获得圆周率</span></span><br><span class="line">pow(m, n)       <span class="comment">-- m^n</span></span><br><span class="line">sqrt(x)         <span class="comment">-- 算术平方根</span></span><br><span class="line">rand()          <span class="comment">-- 随机数</span></span><br><span class="line"><span class="keyword">truncate</span>(x, d)  <span class="comment">-- 截取d位小数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 时间日期函数</span></span><br><span class="line"><span class="keyword">now</span>(), <span class="keyword">current_timestamp</span>();     <span class="comment">-- 当前日期时间</span></span><br><span class="line">current_date();                 <span class="comment">-- 当前日期</span></span><br><span class="line">current_time();                 <span class="comment">-- 当前时间</span></span><br><span class="line">date('yyyy-mm-dd hh:ii:ss');    <span class="comment">-- 获取日期部分</span></span><br><span class="line">time('yyyy-mm-dd hh:ii:ss');    <span class="comment">-- 获取时间部分</span></span><br><span class="line">date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); <span class="comment">-- 格式化时间</span></span><br><span class="line">unix_timestamp();               <span class="comment">-- 获得unix时间戳</span></span><br><span class="line">from_unixtime();                <span class="comment">-- 从时间戳获得时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串函数</span></span><br><span class="line">length(string)          <span class="comment">-- string长度，字节</span></span><br><span class="line">char_length(string)     <span class="comment">-- string的字符个数</span></span><br><span class="line">substring(str, position [,length])      <span class="comment">-- 从str的position开始,取length个字符</span></span><br><span class="line"><span class="keyword">replace</span>(<span class="keyword">str</span> ,search_str ,replace_str)   <span class="comment">-- 在str中用replace_str替换search_str</span></span><br><span class="line"><span class="keyword">instr</span>(<span class="keyword">string</span> ,<span class="keyword">substring</span>)    <span class="comment">-- 返回substring首次在string中出现的位置</span></span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">string</span> [,...])   <span class="comment">-- 连接字串</span></span><br><span class="line"><span class="keyword">charset</span>(<span class="keyword">str</span>)            <span class="comment">-- 返回字串字符集</span></span><br><span class="line"><span class="keyword">lcase</span>(<span class="keyword">string</span>)           <span class="comment">-- 转换成小写</span></span><br><span class="line"><span class="keyword">left</span>(<span class="keyword">string</span>, <span class="keyword">length</span>)    <span class="comment">-- 从string2中的左边起取length个字符</span></span><br><span class="line"><span class="keyword">load_file</span>(file_name)    <span class="comment">-- 从文件读取内容</span></span><br><span class="line"><span class="keyword">locate</span>(<span class="keyword">substring</span>, <span class="keyword">string</span> [,start_position]) <span class="comment">-- 同instr,但可指定开始位置</span></span><br><span class="line"><span class="keyword">lpad</span>(<span class="keyword">string</span>, <span class="keyword">length</span>, <span class="keyword">pad</span>)   <span class="comment">-- 重复用pad加在string开头,直到字串长度为length</span></span><br><span class="line"><span class="keyword">ltrim</span>(<span class="keyword">string</span>)           <span class="comment">-- 去除前端空格</span></span><br><span class="line"><span class="keyword">repeat</span>(<span class="keyword">string</span>, <span class="keyword">count</span>)   <span class="comment">-- 重复count次</span></span><br><span class="line">rpad(<span class="keyword">string</span>, <span class="keyword">length</span>, <span class="keyword">pad</span>)   <span class="comment">--在str后用pad补充,直到长度为length</span></span><br><span class="line"><span class="keyword">rtrim</span>(<span class="keyword">string</span>)           <span class="comment">-- 去除后端空格</span></span><br><span class="line"><span class="keyword">strcmp</span>(string1 ,string2)    <span class="comment">-- 逐字符比较两字串大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 流程函数</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">when</span> [condition] <span class="keyword">then</span> <span class="keyword">result</span> [<span class="keyword">when</span> [condition] <span class="keyword">then</span> <span class="keyword">result</span> ...] [<span class="keyword">else</span> <span class="keyword">result</span>] <span class="keyword">end</span>   多分支</span><br><span class="line"><span class="keyword">if</span>(expr1,expr2,expr3)  双分支。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="keyword">count</span>()</span><br><span class="line"><span class="keyword">sum</span>();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其他常用函数</span></span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 存储函数，自定义函数 ----------</span></span><br><span class="line"><span class="comment">-- 新建</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name (参数列表) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">        函数体</span><br><span class="line"></span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由<span class="string">"参数名"</span>和<span class="string">"参数类型"</span>组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 <span class="keyword">return</span> 返回值语句。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] function_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'partten'</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> function_name 函数选项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 存储过程，自定义功能 ----------</span></span><br><span class="line"><span class="comment">-- 定义</span></span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的<span class="keyword">sql</span>组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过<span class="keyword">call</span>执行。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line"></span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line"><span class="keyword">IN</span>，表示输入型</span><br><span class="line"><span class="keyword">OUT</span>，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line"></span><br><span class="line">注意，没有返回值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储过程 */</span> <span class="comment">------------------</span></span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：<span class="keyword">CALL</span> 过程名</span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 参数</span></span><br><span class="line"><span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT 参数名 数据类型</span><br><span class="line"><span class="keyword">IN</span>      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line"><span class="keyword">OUT</span>     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 过程名 (参数列表)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    过程体</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用户和权限管理 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- root密码重置</span></span><br><span class="line"><span class="number">1.</span> 停止MySQL服务</span><br><span class="line"><span class="number">2.</span>  [Linux] /usr/<span class="keyword">local</span>/mysql/<span class="keyword">bin</span>/safe_mysqld <span class="comment">--skip-grant-tables &amp;</span></span><br><span class="line">    [Windows] mysqld <span class="comment">--skip-grant-tables</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">use</span> mysql;</span><br><span class="line">4. <span class="keyword">UPDATE</span> <span class="string">`user`</span> <span class="keyword">SET</span> <span class="keyword">PASSWORD</span>=<span class="keyword">PASSWORD</span>(<span class="string">"密码"</span>) <span class="keyword">WHERE</span> <span class="string">`user`</span> = <span class="string">"root"</span>;</span><br><span class="line">5. <span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"></span><br><span class="line">用户信息表：mysql.user</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"><span class="comment">-- 增加用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">PASSWORD</span>] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局<span class="keyword">CREATE</span> <span class="keyword">USER</span>权限，或拥有<span class="keyword">INSERT</span>权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 <span class="string">'user_name'</span>@<span class="string">'192.168.1.1'</span></span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略<span class="keyword">PASSWORD</span>关键词。要把密码指定为由<span class="keyword">PASSWORD</span>()函数返回的混编值，需包含关键字<span class="keyword">PASSWORD</span></span><br><span class="line"><span class="comment">-- 重命名用户</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> old_user <span class="keyword">TO</span> new_user</span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">PASSWORD</span>(<span class="string">'密码'</span>)  <span class="comment">-- 为当前用户设置密码</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> 用户名 = <span class="keyword">PASSWORD</span>(<span class="string">'密码'</span>) <span class="comment">-- 为指定用户设置密码</span></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> 用户名</span><br><span class="line"><span class="comment">-- 分配权限/添加用户</span></span><br><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户名 [<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">PASSWORD</span>] <span class="string">'password'</span>]</span><br><span class="line">    - <span class="keyword">all</span> <span class="keyword">privileges</span> 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> <span class="string">`pms`</span>.* <span class="keyword">TO</span> <span class="string">'pms'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'pms0817'</span>;</span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> 用户名</span><br><span class="line">    <span class="comment">-- 查看当前用户权限</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span>; 或 <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>; 或 <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>();</span><br><span class="line"><span class="comment">-- 撤消权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">FROM</span> 用户名</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span>, <span class="keyword">GRANT</span> <span class="keyword">OPTION</span> <span class="keyword">FROM</span> 用户名   <span class="comment">-- 撤销所有权限</span></span><br><span class="line"><span class="comment">-- 权限层级</span></span><br><span class="line"><span class="comment">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span></span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.*和 <span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.*和<span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.tbl_name和<span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用<span class="keyword">REVOKE</span>时，您必须指定与被授权列相同的列。</span><br><span class="line"><span class="comment">-- 权限列表</span></span><br><span class="line"><span class="keyword">ALL</span> [<span class="keyword">PRIVILEGES</span>]    <span class="comment">-- 设置除GRANT OPTION之外的所有简单权限</span></span><br><span class="line"><span class="keyword">ALTER</span>   <span class="comment">-- 允许使用ALTER TABLE</span></span><br><span class="line"><span class="keyword">ALTER</span> ROUTINE   <span class="comment">-- 更改或取消已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span>  <span class="comment">-- 允许使用CREATE TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> ROUTINE  <span class="comment">-- 创建已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLES</span>     <span class="comment">-- 允许使用CREATE TEMPORARY TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>     <span class="comment">-- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span>     <span class="comment">-- 允许使用CREATE VIEW</span></span><br><span class="line"><span class="keyword">DELETE</span>  <span class="comment">-- 允许使用DELETE</span></span><br><span class="line"><span class="keyword">DROP</span>    <span class="comment">-- 允许使用DROP TABLE</span></span><br><span class="line"><span class="keyword">EXECUTE</span>     <span class="comment">-- 允许用户运行已存储的子程序</span></span><br><span class="line"><span class="keyword">FILE</span>    <span class="comment">-- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span></span><br><span class="line"><span class="keyword">INDEX</span>   <span class="comment">-- 允许使用CREATE INDEX和DROP INDEX</span></span><br><span class="line"><span class="keyword">INSERT</span>  <span class="comment">-- 允许使用INSERT</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span>     <span class="comment">-- 允许对您拥有SELECT权限的表使用LOCK TABLES</span></span><br><span class="line">PROCESS     <span class="comment">-- 允许使用SHOW FULL PROCESSLIST</span></span><br><span class="line"><span class="keyword">REFERENCES</span>  <span class="comment">-- 未被实施</span></span><br><span class="line">RELOAD  <span class="comment">-- 允许使用FLUSH</span></span><br><span class="line"><span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span>  <span class="comment">-- 允许用户询问从属服务器或主服务器的地址</span></span><br><span class="line"><span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>   <span class="comment">-- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="comment">-- 允许使用SELECT</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>  <span class="comment">-- 显示所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VIEW</span>   <span class="comment">-- 允许使用SHOW CREATE VIEW</span></span><br><span class="line"><span class="keyword">SHUTDOWN</span>    <span class="comment">-- 允许使用mysqladmin shutdown</span></span><br><span class="line">SUPER   <span class="comment">-- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），</span></span><br><span class="line">        <span class="comment">-- 即使已达到max_connections。</span></span><br><span class="line"><span class="keyword">UPDATE</span>  <span class="comment">-- 允许使用UPDATE</span></span><br><span class="line"><span class="keyword">USAGE</span>   <span class="comment">-- “无权限”的同义词</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">OPTION</span>    <span class="comment">-- 允许授予权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表维护 */</span></span><br><span class="line"><span class="comment">-- 分析和存储表的关键字分布</span></span><br><span class="line"><span class="keyword">ANALYZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> 表名 ...</span><br><span class="line"><span class="comment">-- 检查一个或多个表是否有错误</span></span><br><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [<span class="keyword">option</span>] ...</span><br><span class="line"><span class="keyword">option</span> = &#123;<span class="keyword">QUICK</span> | <span class="keyword">FAST</span> | <span class="keyword">MEDIUM</span> | <span class="keyword">EXTENDED</span> | <span class="keyword">CHANGED</span>&#125;</span><br><span class="line"><span class="comment">-- 整理数据文件的碎片</span></span><br><span class="line"><span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 杂项 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="number">1.</span> 可用反引号（<span class="string">`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span></span><br><span class="line"><span class="string">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span></span><br><span class="line"><span class="string">3. 注释：</span></span><br><span class="line"><span class="string">    单行注释 # 注释内容</span></span><br><span class="line"><span class="string">    多行注释 /* 注释内容 */</span></span><br><span class="line"><span class="string">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span></span><br><span class="line"><span class="string">4. 模式通配符：</span></span><br><span class="line"><span class="string">    _   任意单个字符</span></span><br><span class="line"><span class="string">    %   任意多个字符，甚至包括零字符</span></span><br><span class="line"><span class="string">    单引号需要进行转义 \'</span></span><br><span class="line"><span class="string">5. CMD命令行内的语句结束符可以为 ";", "\G", "\g"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span></span><br><span class="line"><span class="string">6. SQL对大小写不敏感</span></span><br><span class="line"><span class="string">7. 清除已有语句：\c</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>source etc/profile重新ssh上去失效</title>
    <url>/posts/ubuntu-source/</url>
    <content><![CDATA[<p>本篇博客主要探讨了一下Linux配置环境变量执行顺序问题。</p><a id="more"></a><h2 id="linux环境配置文件"><a href="#linux环境配置文件" class="headerlink" title="linux环境配置文件"></a>linux环境配置文件</h2><p>linux环境变量配置的文件有一下几种</p><ul><li>/etc/environment</li><li>/etc/profile</li><li>/etc/bashrc(在Ubuntu中文件名为bash.bashrc)</li><li>~/.profile</li><li>~/.bashrc</li></ul><h2 id="linux配置文件执行顺序"><a href="#linux配置文件执行顺序" class="headerlink" title="linux配置文件执行顺序"></a>linux配置文件执行顺序</h2><p>/etc/environment文件是整个系统的环境变量配置，最先执行的，之后是/etc/profile执行，/etc/profile脚本里面有一个逻辑是如果/etc/bashrc（Ubuntu是bash.bashrc）文件存在，则执行此文件。然后执行用户目录下的.profile文件，这个文件有一个逻辑是如果~/.bashrc存在，则执行此文件。</p><p>今天服务器配置java环境变量的时候，在/etc/environment执行完之后reboot之后java -version有用，退出shell之后重新登录无效，遂改在了/etc/profile文件中，然而依旧是重启第一次有效，退出shell之后重新登录依然无效。后查阅资料发现要在~/.bashrc文件下执行以下source /etc/profile才会生效，于我依然无效。</p><p>最后我纳闷了，按理说/etc/environment和/etc/profile文件应该配置之后启动就会生效的，为何我退出重新进入shell就无效了呢？而且我发现，我用shell登录到服务器的时候，/etc/profile文件和~/.bashrc的echo输出语句无效，并没有执行输出。<br>经过多方资料的查阅之后了解到一下两种模式：</p><ul><li>su这种登录情况会执行/etc/profile文件和~/.profile文件</li><li>直接通过终端ssh上去则只会执行/etc/bashrc和~/.bashrc文件</li><li>我用的是zsh，所以ssh上去不执行~/.bashrc而是执行~/.zshrc</li></ul><p>第二点和第三点其实算是一点，因为ssh上去的只会执行当然脚本当前使用的shell配置文件，因为我使用的是zsh，所以执行的是~/.zshrc而不是~/.bashrc。当然，这是我测试出来的，你要问我严谨不，那肯定不严谨。但是我在两个文件分别echo输出文字，只有~/.zshrc文件输出了，所以我就暂且这么猜了。</p><p>因此，环境变量我配置在/etc/profile文件下，只要在~/.zshrc(或者使用用bash的在~/.bashrc文件中)里面加一个判断就能解决ssh登录不加载/etc/profile的问题了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -d /etc/profile ]; then</span><br><span class="line">  source /etc/profile</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>アイロニ</title>
    <url>/posts/%E3%82%A2%E3%82%A4%E3%83%AD%E3%83%8B/</url>
    <content><![CDATA[<blockquote><p>希望每一个说着“我真没用啊”的人都能有个人能拍着自己的肩说：“其实你也并不差啦”</p></blockquote><a id="more"></a><blockquote><p>少し歩き疲れたんだ<br>有些走累了呢</p><p>少し歩き疲れたんだ<br>有些走累了呢</p><p>月並みな表現だけど<br>虽然以那麼平凡的表现</p><p>人生とかいう長い道を<br>来形容人生的漫长道路</p><p>少し休みたいんだ<br>想稍稍休息下呢</p><p>少し休みたいんだけど<br>想稍稍休息下呢</p><p>時間は刻一刻残酷と<br>时间每分每刻都这样残酷</p><p>私を 引っぱっていくんだ<br>将我紧拖著前行</p><p>うまくいきそうなんだけど<br>虽然看似顺利进行著</p><p>うまくいかないことばかりで<br>但其实全是不顺利的事</p><p>迂闊にも泣いてしまいそうになる<br>却糊涂地哭了起来</p><p>情けない本当にな<br>真是丢人呢</p><p>惨めな気持ちなんか<br>这样悲惨的感受</p><p>嫌というほど味わってきたし<br>已经体验到不想再有了</p><p>とっくに悔しさなんてものは<br>但明明应该将悔恨之类</p><p>捨ててきたはずなのに<br>早已丢弃了</p><p>絶望抱くほど<br>虽也不是感到绝望般</p><p>悪いわけじゃないけど<br>那样差劲</p><p>欲しいものは<br>但希望的东西</p><p>いつも少し手には届かない<br>却永远得不到手</p><p>そんな半端だとねなんか<br>对这样没有用的家伙</p><p>期待してしまうから<br>为什麼会有所期待呢</p><p>それならもういっそのこと<br>既然如此不如乾脆</p><p>ドン底まで突き落としてよ<br>将它推入谷底吧</p><p>答えなんて言われたって<br>即使要说答案</p><p>人によってすり替わってって<br>因人不同也会有所改变</p><p>だから絶対なんて絶対<br>所以绝对之类绝对</p><p>信じらんないよねぇ<br>是不能相信的 是吧</p><p>苦しみって誰にもあるって<br>谁都会有苦楚</p><p>そんなのわかってるから何だって<br>说著这谁都明白</p><p>なら笑って済ませばいいの？<br>那就笑著过去就好了吧？</p><p>もうわかんないよバカ！<br>我不知道该怎麼办啦 笨蛋！</p><p>散々言われてきたくせに<br>明明是被狠狠说了一番</p><p>なんだまんざらでもないんだ<br>但却未必就是这样</p><p>簡単に考えたら楽なことも<br>将简单思考起来很容易的事</p><p>難関に考えてたんだ<br>也当做难题考虑了</p><p>段々と色々めんどくなってもう<br>种种事都越发麻烦</p><p>淡々と終わらせちゃおうか<br>让一切都淡淡结束吧</p><p>「病んだ？」とかもう嫌になったから<br>「病了吗？」之类已经受够了</p><p>やんわりと終わればもういいじゃんか<br>能温和地结束不就好了吗</p><p>夢だとか希望とか<br>梦也好希望也好</p><p>生きてる意味とか<br>又或是生存意义</p><p>別にそんなものはさして<br>那些东西也并不是</p><p>必要ないから<br>一定有必要存在</p><p>具体的でわかりやすい<br>请给我具体易懂的</p><p>機会をください<br>这样的机会</p><p>泣き場所探すうちに<br>在寻找哭泣的地方时</p><p>もう泣き疲れちゃったよ<br>就已经哭累了啊</p><p>きれいごとって嫌いだって<br>讨厌华而不实的话</p><p>期待しちゃっても形になんなくて<br>期待著却捉不到蛛丝马迹</p><p>「星が僕ら見守って」って<br>要说「星星守护著我们」</p><p>夜しかいないじゃん　ねぇ<br>那也就只有晚上 对吗</p><p>君のその優しいとこ<br>你的温柔</p><p>不覚にも求めちゃうから<br>我在不知不觉中寻求著</p><p>この心やらかいとこ<br>这颗心的柔软</p><p>もう触んないで　ヤダ！<br>请不要触碰了 不要！</p><p>もうほっといて<br>不要管了</p><p>もう置いてって<br>丢下我吧</p><p>汚れきったこの道は<br>弄脏的这条路</p><p>もう変わんないよ嗚呼<br>已经无法改变了啊</p><p>疲れちゃって弱気になって<br>疲倦了变得懦弱了</p><p>逃げ出したって無駄なんだって<br>想要逃也是白费力气</p><p>だから内面耳塞いで<br>所以内心捂著耳朵</p><p>もう最低だって泣いて<br>哭著这已经是最后</p><p>人生って何なのって<br>人生又是什麼呢</p><p>わかんなくても生きてるだけで<br>只是不明不白地活著</p><p>幸せって思えばいいの？<br>认为这就是幸福就可以吗？</p><p>もうわかんないよバカ！<br>我不明白了啦 笨蛋！</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26447698&auto=1&height=66"></iframe>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
